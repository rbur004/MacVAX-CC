#include <Retrace.h>#include "AnimateCursor.h"#define InterruptDelay		30#define MaxNumberCursors	16	// maximum number of cursors in animation// Local function prototypespascal long GetVBLRec( void );static pascal void ChangeCursor( void );typedef CursHandle CursorsList[MaxNumberCursors];typedef	struct	{	VBLTask		myVBLTask;	CursorsList	myCursors;	short		myFrame;	short		numberOfCursors;	} CursorTask, *CursorTaskPtr;// Define some globals...CursorTask	gMyCursorTask;VBLUPP		gVBLRoutine;// Returns address of a VBL task record, from within a VBL taskpascal long GetVBLRec( void )	ONEWORDINLINE( 0x2E88 );		// MOVE.L A0, (A7)// This is the task that is executed during a VBL// NOTE: can not have debug information in an interrupt routine!static pascal void ChangeCursor( void )	{	CursorTaskPtr	RecPtr;	// Get cursor information.	RecPtr = (CursorTaskPtr) GetVBLRec();    // Display the next cursor	SetCursor( *( RecPtr->myCursors[RecPtr->myFrame] ));    // Advance to the next cursor frame	RecPtr->myFrame++;	// Wrap around to the first cursor	if (RecPtr->myFrame >= RecPtr->numberOfCursors)		RecPtr->myFrame = 0;	// Set task to run again	RecPtr->myVBLTask.vblCount = InterruptDelay;		}// Call this procedure to start a moving cursor.#define kInitialDelay	10void StartSpinning( short NumOfCursors, short InitialResID )	{	OSErr	myError;	short	count;	// Initialise cursor information	gMyCursorTask.numberOfCursors = NumOfCursors;	for ( count = 0; count < NumOfCursors; count++ )		{		    	// Load cursor into memory.		gMyCursorTask.myCursors[ count ] = GetCursor( InitialResID + count );    	// Lock cursor so that we can call SetCursor at Interrupt time.		HLockHi( ( Handle ) gMyCursorTask.myCursors[ count ] );				}	gMyCursorTask.myFrame = 0;	// Create the universal proc pointer for the VBL task function.	gVBLRoutine = NewVBLProc( ChangeCursor );	// Initialise the VBL task record.	gMyCursorTask.myVBLTask.qType = vType;				// Set queue type	gMyCursorTask.myVBLTask.vblAddr = gVBLRoutine;		// Get address of VBL task	gMyCursorTask.myVBLTask.vblCount = kInitialDelay;	// Set task frequency/delay	gMyCursorTask.myVBLTask.vblPhase = 0;				// No phase	// Dispose the VBL task universal proc pointer.  	// Install the interrupt.	myError = VInstall( (QElemPtr) &gMyCursorTask.myVBLTask );		}// Call this to stop the moving/spinning cursor.void StopSpinning( void )	{	OSErr myError;	short count;	// Remove the task record from its queue.	myError = VRemove( (QElemPtr) &gMyCursorTask.myVBLTask );	SetCursor( &qd.arrow );	// Free memory occupied by the cursors.	for ( count = 0; count < gMyCursorTask.numberOfCursors; count++ )		ReleaseResource( ( Handle ) gMyCursorTask.myCursors[ count ] );	DisposeRoutineDescriptor( gVBLRoutine );	}