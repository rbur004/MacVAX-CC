/*	*sccsid = "@(#)common	1.4	(ULTRIX)	3/12/86"; *//************************************************************************ *									* *			Copyright (c) 1984 by				* *		Digital Equipment Corporation, Maynard, MA		* *			All rights reserved.				* *									* *   This software is furnished under a license and may be used and	* *   copied  only  in accordance with the terms of such license and	* *   with the  inclusion  of  the  above  copyright  notice.   This	* *   software  or  any  other copies thereof may not be provided or	* *   otherwise made available to any other person.  No title to and	* *   ownership of the software is hereby transferred.			* *									* *   This software is  derived  from  software  received  from  the	* *   University    of   California,   Berkeley,   and   from   Bell	* *   Laboratories.  Use, duplication, or disclosure is  subject  to	* *   restrictions  under  license  agreements  with  University  of	* *   California and with AT&T.						* *									* *   The information in this software is subject to change  without	* *   notice  and should not be construed as a commitment by Digital	* *   Equipment Corporation.						* *									* *   Digital assumes no responsibility for the use  or  reliability	* *   of its software on equipment which is not supplied by Digital.	* *									* ************************************************************************//*************************************************************** * *		Modification History *	 *	Lu Anne Van de Pas, 02-Mar-86 * 004- Added DCON for double constants.  FCON is now for single precion *	constants only.  * *	Victoria Holt, 26-Feb-86 * 003- Added INITASSIGN to enable initialization of const types. * *	Rich Phillips, 13-Sept-84 * 002- Back out of 001 (nflags has been removed) * *	Rich Phillips, 20-July-84 * 001- Clear nflags when nodes are allocated. * ***************************************************************/ #include <stdarg.h>#include <stdlib.h>#include <string.h>#include "ccom_mfile1.h"#include "ccom_code.h"#include "ccom_common.h"#if macVax#include "ccom_globals.h"#endif#ifdef FORT#undef BUFSTDERR#endif#ifndef ONEPASS#undef BUFSTDERR#endif# ifndef EXIT# define EXIT fflush(stderr);fflush(stdout);exit# endifint nerrors;  /* number of errors */extern unsigned int offsz;unsigned int caloff( void ){	register i;	unsigned int temp;	unsigned int off;	temp = 1;	i = 0;	do {		temp <<= 1;		++i;		} while( temp > 0 );	off = 1 << (i-1);	return (off);	}NODE *lastfree;  /* pointer to last free node; (for allocator) */	/* VARARGS1 */void uerror( char *s, ... ){ /* nonfatal error message */	/* the routine where is different for pass 1 and pass 2;	/*  it tells where the error took place */	int a;	va_list va;	va_start( va, s );	a = va_arg( va, int );	va_end( va );	++nerrors;	where('u');	fprintf( stderr, s, a );	fprintf( stderr, "\n" );#ifdef BUFSTDERR	fflush(stderr);#endif	if( nerrors > 30 ) cerror( "Too many errors" );	}	/* VARARGS1 */void cerror( char *s, ... ){ /* compiler error: die */		int a, b, c;	va_list va;	va_start( va, s );	a = va_arg( va, int );	b = va_arg( va, int );	c = va_arg( va, int );	va_end( va );	where('c');	if( nerrors && nerrors <= 30 ){ /* give the compiler the benefit of the doubt */		fprintf( stderr, "Cannot recover from earlier errors: goodbye!\n" );		}	else {		fprintf( stderr, "Compiler error: " );		fprintf( stderr, s, a, b, c );		fprintf( stderr, "\n" );		}#ifdef BUFSTDERR	fflush(stderr);#endif	EXIT(1);	}int Wflag; /* Non-zero means do not print warnings */	/* VARARGS1 */void werror( char *s, ... ){  /* warning */	int a, b;	va_list va;	va_start( va, s );	a = va_arg( va, int );	b = va_arg( va, int );	va_end( va );	if(Wflag) return;	where('w');	fprintf( stderr, "Warning: " );	fprintf( stderr, s, a, b );	fprintf( stderr, "\n" );#ifdef BUFSTDERR	fflush(stderr);#endif	}void tinit( void ){ /* initialize expression tree search */	NODE *p;	for( p=node; p<= &node[TREESZ-1]; ++p ) p->in.op = FREE;	lastfree = node;	}# define TNEXT(p) (p== &node[TREESZ-1]?node:p+1)NODE *talloc( void ){	NODE *p, *q;	q = lastfree;	for( p = TNEXT(q); p!=q; p= TNEXT(p))		if( p->in.op ==FREE ) {			return(lastfree=p);		}	cerror( "Out of tree space; simplify expression");	/* NOTREACHED */	}void tcheck( void ){ /* ensure that all nodes have been freed */	NODE *p;	if( !nerrors )		for( p=node; p<= &node[TREESZ-1]; ++p )			if( p->in.op != FREE ) cerror( "Wasted space: %o", p );	tinit();#ifdef FLEXNAMES	freetstr();#endif	}void tfree( NODE *p ){	/* free the tree p */	if( p->in.op != FREE ) walkf( p, tfree1 );	}void tfree1( NODE *p ){	if( p == 0 ) cerror( "Freeing blank tree!");	else p->in.op = FREE;}void fwalk( register NODE *t, void (*f)(register NODE *, int, int *, int *), int down ){	int down1, down2;	more:	down1 = down2 = 0;	(*f)( t, down, &down1, &down2 );	switch( optype( t->in.op ) ){	case BITYPE:		fwalk( t->in.left, f, down1 );		t = t->in.right;		down = down2;		goto more;	case UTYPE:		t = t->in.left;		down = down1;		goto more;		}	}void walkf( NODE *t, void (*f)( NODE * ) ){	register opty;	opty = optype(t->in.op);	if( opty != LTYPE ) walkf( t->in.left, f );	if( opty == BITYPE ) walkf( t->in.right, f );	(*f)( t );	}int dope[ DSIZE ];char *opst[DSIZE];struct dopest { int dopeop; char opst[8]; int dopeval; } indope[] = {	NAME, "NAME", LTYPE,	STRING, "STRING", LTYPE,	REG, "REG", LTYPE,	OREG, "OREG", LTYPE,	ICON, "ICON", LTYPE,	FCON, "FCON", LTYPE,	DCON, "DCON", LTYPE,	CCODES, "CCODES", LTYPE,	UNARY MINUS, "U-", UTYPE,	UNARY MUL, "U*", UTYPE,	UNARY AND, "U&", UTYPE,	UNARY CALL, "UCALL", UTYPE|CALLFLG,	UNARY FORTCALL, "UFCALL", UTYPE|CALLFLG,	NOT, "!", UTYPE|LOGFLG,	COMPL, "~", UTYPE,	FORCE, "FORCE", UTYPE,	INIT, "INIT", UTYPE,	SCONV, "SCONV", UTYPE,	PCONV, "PCONV", UTYPE,	PLUS, "+", BITYPE|FLOFLG|SIMPFLG|COMMFLG,	ASG PLUS, "+=", BITYPE|ASGFLG|ASGOPFLG|FLOFLG|SIMPFLG|COMMFLG,	MINUS, "-", BITYPE|FLOFLG|SIMPFLG,	ASG MINUS, "-=", BITYPE|FLOFLG|SIMPFLG|ASGFLG|ASGOPFLG,	MUL, "*", BITYPE|FLOFLG|MULFLG,	ASG MUL, "*=", BITYPE|FLOFLG|MULFLG|ASGFLG|ASGOPFLG,	AND, "&", BITYPE|SIMPFLG|COMMFLG,	ASG AND, "&=", BITYPE|SIMPFLG|COMMFLG|ASGFLG|ASGOPFLG,	QUEST, "?", BITYPE,	COLON, ":", BITYPE,	ANDAND, "&&", BITYPE|LOGFLG,	OROR, "||", BITYPE|LOGFLG,	CM, ",", BITYPE,	COMOP, ",OP", BITYPE,	ASSIGN, "=", BITYPE|ASGFLG,	DIV, "/", BITYPE|FLOFLG|MULFLG|DIVFLG,	ASG DIV, "/=", BITYPE|FLOFLG|MULFLG|DIVFLG|ASGFLG|ASGOPFLG,	MOD, "%", BITYPE|DIVFLG,	ASG MOD, "%=", BITYPE|DIVFLG|ASGFLG|ASGOPFLG,	LS, "<<", BITYPE|SHFFLG,	ASG LS, "<<=", BITYPE|SHFFLG|ASGFLG|ASGOPFLG,	RS, ">>", BITYPE|SHFFLG,	ASG RS, ">>=", BITYPE|SHFFLG|ASGFLG|ASGOPFLG,	OR, "|", BITYPE|COMMFLG|SIMPFLG,	ASG OR, "|=", BITYPE|COMMFLG|SIMPFLG|ASGFLG|ASGOPFLG,	ER, "^", BITYPE|COMMFLG|SIMPFLG,	ASG ER, "^=", BITYPE|COMMFLG|SIMPFLG|ASGFLG|ASGOPFLG,	INCR, "++", BITYPE|ASGFLG,	DECR, "--", BITYPE|ASGFLG,	STREF, "->", BITYPE,	CALL, "CALL", BITYPE|CALLFLG,	FORTCALL, "FCALL", BITYPE|CALLFLG,	EQ, "==", BITYPE|LOGFLG,	NE, "!=", BITYPE|LOGFLG,	LE, "<=", BITYPE|LOGFLG,	LT, "<", BITYPE|LOGFLG,	GE, ">", BITYPE|LOGFLG,	GT, ">", BITYPE|LOGFLG,	UGT, "UGT", BITYPE|LOGFLG,	UGE, "UGE", BITYPE|LOGFLG,	ULT, "ULT", BITYPE|LOGFLG,	ULE, "ULE", BITYPE|LOGFLG,	ARS, "A>>", BITYPE,	TYPE, "TYPE", LTYPE,	LB, "[", BITYPE,	CBRANCH, "CBRANCH", BITYPE,	FLD, "FLD", UTYPE,	PMCONV, "PMCONV", BITYPE,	PVCONV, "PVCONV", BITYPE,	RETURN, "RETURN", BITYPE|ASGFLG|ASGOPFLG,	CAST, "CAST", BITYPE|ASGFLG|ASGOPFLG,	GOTO, "GOTO", UTYPE,	STASG, "STASG", BITYPE|ASGFLG,	STARG, "STARG", UTYPE,	STCALL, "STCALL", BITYPE|CALLFLG,	UNARY STCALL, "USTCALL", UTYPE|CALLFLG,	INITASSIGN, "=", BITYPE,-1,	0};void mkdope( void )	{	register struct dopest *q;	for( q = indope; q->dopeop >= 0; ++q ){		dope[q->dopeop] = q->dopeval;		opst[q->dopeop] = q->opst;		}	}# ifndef BUG4void tprint( TWORD t )	{ /* output a nice description of the type of t */	static char * tnames[] = {		"undef",		"farg",		"char",		"short",		"int",		"long",		"float",		"double",		"strty",		"unionty",		"enumty",		"moety",		"uchar",		"ushort",		"unsigned",		"ulong",		"?", "?"		};	for(;; t = DECREF(t) ){		if( ISPTR(t) ) printf( "PTR " );		else if( ISFTN(t) ) printf( "FTN " );		else if( ISARY(t) ) printf( "ARY " );		else {			printf( "%s", tnames[t] );			return;			}		}	}# endif#ifdef FLEXNAMESchar	itstrbuf[TSTRSZ];	/* Apparently unused - DWG */char	*tstrbuf[NTSTRBUF];char	**curtstr;int	tstrused;char *tstr(register char *cp){	register int i = strlen(cp);	register char *dp;		/* tstrused is how far through the current string buffer we are */	if (tstrused + i >= TSTRSZ) {		if (++curtstr >= &tstrbuf[NTSTRBUF])			cerror("Out of temporary string space");	/* Exit on error */		tstrused = 0;		if (*curtstr == 0) {			dp = (char *)malloc(TSTRSZ);			if (dp == 0)				cerror("Out of memory (tstr)");			*curtstr = dp;		}	}	strcpy(dp = *curtstr+tstrused, cp);	tstrused += i + 1;	return (dp);}#endifvoid common_init_statics( void ){	nerrors = 0;#ifdef FLEXNAMES/*char	*tstrbuf[NTSTRBUF] = { itstrbuf };char	**curtstr = tstrbuf;*/	memset( tstrbuf, 0, sizeof(tstrbuf) );	tstrbuf[0] = itstrbuf;	curtstr = tstrbuf;	tstrused = 0;#endif}