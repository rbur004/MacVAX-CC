#ifndef lintstatic	char	*sccsid = "@(#)code.c	1.2	(ULTRIX)	2/28/86";#endif /************************************************************************ *									* *			Copyright (c) 1985 by				* *		Digital Equipment Corporation, Maynard, MA		* *			All rights reserved.				* *									* *   This software is furnished under a license and may be used and	* *   copied  only  in accordance with the terms of such license and	* *   with the  inclusion  of  the  above  copyright  notice.   This	* *   software  or  any  other copies thereof may not be provided or	* *   otherwise made available to any other person.  No title to and	* *   ownership of the software is hereby transferred.			* *									* *   This software is  derived  from  software  received  from  the	* *   University    of   California,   Berkeley,   and   from   Bell	* *   Laboratories.  Use, duplication, or disclosure is  subject  to	* *   restrictions  under  license  agreements  with  University  of	* *   California and with AT&T.						* *									* *   The information in this software is subject to change  without	* *   notice  and should not be construed as a commitment by Digital	* *   Equipment Corporation.						* *									* *   Digital assumes no responsibility for the use  or  reliability	* *   of its software on equipment which is not supplied by Digital.	* *									* ************************************************************************//************************************************************************ * *		Modification History * *	Victoria Holt, 27-Feb-86 * 002	Added the case RODATA for future use (to write const types *	into text space). * *	David L. Ballenger, 26-Feb-86 * 001	Changed ".align 1" to ".align 2" in efocde() to enable longword *	alignment of routines. * ******************************************************************/#include "ccom_mfile1.h"#include "ccom_code.h"#include "ccom_common.h"#include "ccom_local.h"#include "ccom_pftn.h"#include "ccom_reader.h"#include "ccom_scan.h"#include "ccom_trees.h"/* The following variables were static to functions, but   for the mac version we need to be able to reinitialize   them */#ifdef ASSTRINGSstatic int	bycode_lastoctal;#endifint proflg;	/* are we generating profiling code? */int strftn;  /* is the current function one which returns a value */int gdebug;int fdefflag;  /* are we within a function definition ? */char NULLNAME[8];int labelno;#if macVaxvoid code_init_statics( void ){#	ifdef ASSTRINGS	bycode_lastoctal = 0;#	endif}#endif /* macVax */void branch( int n ){	/* output a branch to label n */	/* exception is an ordinary function branching to retlab: then, return */	if( n == retlab && !strftn ){		printf( "	ret\n" );		}	else printf( "	jbr 	L%d\n", n );	}int lastloc;short log2tab[] = {0, 0, 1, 2, 2, 3, 3, 3, 3};#define LOG2SZ 9void defalign( int n ){	/* cause the alignment to become a multiple of n */	n /= SZCHAR;	if( lastloc != PROG && n > 1 ) printf( "	.align	%d\n", n >= 0 && n < LOG2SZ ? log2tab[n] : 0 );	}int locctr( int l )	{	register temp;	/* l is PROG, RODATA (read-only data), ADATA, DATA, 	 * STRNG, ISTRNG, or STAB */	if( l == lastloc ) return(l);	temp = lastloc;	lastloc = l;	switch( l ){	case PROG:		printf( "	.text\n" );		psline();		break;	case DATA:	case ADATA:		printf( "	.data\n" );		break;	case STRNG:		printf( "	.data	1\n" );		break;	case ISTRNG:		printf( "	.data	2\n" );		break;	case STAB:		printf( "	.stab\n" );		break;	case RODATA:		printf("	.data\n" );		break;	default:		cerror( "Illegal location counter" );		}	return( temp );	}void deflab( int n )	{	/* output something to define the current position as label n */	printf( "L%d:\n", n );	}int crslab;int getlab( void )	{	/* return a number usable for a label */	return( ++crslab );	}int ent_mask[] = {	0,0,0,0,0, 0xfc0, 0xf80, 0xf00, 0xe00, 0xc00, 0x800, 0};int reg_use;void efcode( void )	{	/* code for the end of a function */	if( strftn ){  /* copy output (in R2) to caller */		register NODE *l, *r;		register struct symtab *p;		register TWORD t;		register int j;		int i;		p = &stab[curftn];		t = p->stype;		t = DECREF(t);		deflab( retlab );		i = getlab();	/* label for return area */#ifndef LCOMM		printf("	.data\n" );		printf("	.align	2\n" );		printf("L%d:	.space	%d\n", i, tsize(t, p->dimoff, p->sizoff)/SZCHAR );		printf("	.text\n" );#else		{ int sz = tsize(t, p->dimoff, p->sizoff) / SZCHAR;		if (sz % sizeof (int))			sz += sizeof (int) - (sz % sizeof (int));		printf("	.lcomm	L%d,%d\n", i, sz);		}#endif		psline();		printf("	movab	L%d,r1\n", i);		reached = 1;		l = block( REG, NIL, NIL, PTR|t, p->dimoff, p->sizoff );		l->tn.rval = 1;  /* R1 */		l->tn.lval = 0;  /* no offset */		r = block( REG, NIL, NIL, PTR|t, p->dimoff, p->sizoff );		r->tn.rval = 0;  /* R0 */		r->tn.lval = 0;		l = buildtree( UNARY MUL, l, NIL );		r = buildtree( UNARY MUL, r, NIL );		l = buildtree( ASSIGN, l, r );		l->in.op = FREE;		ecomp( l->in.left );		printf( "	movab	L%d,r0\n", i );		/* turn off strftn flag, so return sequence will be generated */		strftn = 0;		}	branch( retlab );#ifndef VMS	printf( "	.set	L%d,0x%x\n", ftnno, ent_mask[reg_use] );#else	printf( "	.set	L%d,%d	# Hex = 0x%x\n", ftnno, 0x3c| ent_mask[reg_use], ent_mask[reg_use]  );	/* KLS kludge, under VMS if you use regs 2-5, you must save them. */#endif	reg_use = 11;	p2bend();	fdefflag = 0;	}int ftlab1, ftlab2;void bfcode( int a[], int n )	{	/* code for the beginning of a function; a is an array of		indices in stab for the arguments; n is the number */	register i;	register temp;	register struct symtab *p;	int off;	char *toreg();	locctr( PROG );	p = &stab[curftn];	printf( "	.align	2\n");	defnam( p );	temp = p->stype;	temp = DECREF(temp);	strftn = (temp==STRTY) || (temp==UNIONTY);	retlab = getlab();	/* routine prolog */	printf( "	.word	L%d\n", ftnno);	/*	if (gdebug) {#ifdef STABDOT		pstabdot(N_SLINE, lineno);#else		pstab(NULLNAME, N_SLINE);		printf("0,%d,LL%d\n", lineno, labelno);		printf("LL%d:\n", labelno++);#endif	}*/	ftlab1 = getlab();	ftlab2 = getlab();	printf( "	jbr 	L%d\n", ftlab1);	printf( "L%d:\n", ftlab2);	if( proflg ) {	/* profile code */		i = getlab();		printf("	movab	L%d,r0\n", i);		printf("	jsb 	mcount\n");		printf("	.data\n");		printf("	.align	2\n");		printf("L%d:	.long	0\n", i);		printf("	.text\n");		psline();		}	off = ARGINIT;	for( i=0; i<n; ++i ){		p = &stab[a[i]];		if( p->sclass == REGISTER ){			temp = p->offset;  /* save register number */			p->sclass = PARAM;  /* forget that it is a register */			p->offset = NOOFFSET;			oalloc( p, &off );/*tbl*/		printf( "	%s	%d(ap),r%d\n", toreg(p->stype), p->offset/SZCHAR, temp );			p->offset = temp;  /* remember register number */			p->sclass = REGISTER;   /* remember that it is a register */			}		else if( p->stype == STRTY || p->stype == UNIONTY ) {			p->offset = NOOFFSET;			if( oalloc( p, &off ) ) cerror( "Bad argument" );			SETOFF( off, ALSTACK );			}		else {			if( oalloc( p, &off ) ) cerror( "Bad argument" );			}		}	fdefflag = 1;	}void bccode( void )	{ /* called just before the first executable statment */		/* by now, the automatics and register variables are allocated */	SETOFF( autooff, SZINT );	/* set aside store area offset */	p2bbeg( autooff, regvar );	reg_use = (reg_use > regvar ? regvar : reg_use);	}void ejobcode( int flag )	{	/* called just before final exit */	/* flag is 1 if errors, 0 if none */	}void aobeg( void )	{	/* called before removing automatics from stab */	}void aocode( struct symtab *p )	{	/* called when automatic p removed from stab */	}void aoend( void )	{	/* called after removing all automatics from stab */	}void defnam( register struct symtab *p)	{	/* define the current location as the name p->sname */	if( p->sclass == EXTDEF ){		printf( "	.globl	%s\n", exname( p->sname ) );		}	if( p->sclass == STATIC && p->slevel>1 ) deflab( p->offset );	else printf( "%s:\n", exname( p->sname ) );	}void bycode( int t, int i )	{	/* put byte i+1 in a string */#ifdef ASSTRINGS	i &= 077;	if ( t < 0 ){		if ( i != 0 )	printf( "\"\n" );	} else {		if ( i == 0 ) printf("\t.ascii\t\"");		if ( t == '\\' || t == '"'){			bycode_lastoctal = 0;			printf("\\%c", t);		}			/*			 *	We escape the colon in strings so that			 *	c2 will, in its infinite wisdom, interpret			 *	the characters preceding the colon as a label.			 *	If we didn't escape the colon, c2 would			 *	throw away any trailing blanks or tabs after			 *	the colon, but reconstruct a assembly			 *	language semantically correct program.			 *	C2 hasn't been taught about strings.			 */		else if ( t == ':' || t < 040 || t >= 0177 ){			bycode_lastoctal++;			printf("\\%o",t);		}		else if ( bycode_lastoctal && '0' <= t && t <= '9' ){			bycode_lastoctal = 0;			printf("\"\n\t.ascii\t\"%c", t );		}		else		{				bycode_lastoctal = 0;			putchar(t);		}		if ( i == 077 ) printf("\"\n");	}#else	i &= 07;	if( t < 0 ){ /* end of the string */		if( i != 0 ) printf( "\n" );		}	else { /* stash byte t into string */		if( i == 0 ) printf( "	.byte	" );		else printf( "," );		printf( "0x%x", t );		if( i == 07 ) printf( "\n" );		}#endif	}void zecode( int n )	{	/* n integer words of zeros */	OFFSZ temp;	if( n <= 0 ) return;	printf( "	.space	%d\n", (SZINT/SZCHAR)*n );	temp = n;	inoff += temp*SZINT;	}int fldal( unsigned int t )	{ /* return the alignment of field of type t */	uerror( "Illegal field type" );	return( ALINT );	}void fldty( struct symtab *p )	{ /* fix up type of field p */	}void where( int c )	{ /* print location of error  */	  /* c is either 'u', 'c', or 'w' */	  /* GCOS version */	fprintf( stderr, "%s, line %d: ", ftitle, lineno );	}/* tbl - toreg() returns a pointer to a char string		  which is the correct  "register move" for the passed type  */struct type_move {TWORD fromtype; char tostrng[8];} toreg_strs[] =	{	CHAR, "cvtbl",	SHORT, "cvtwl",	INT, "movl",	LONG, "movl",	FLOAT, "movf",	DOUBLE, "movd",	UCHAR,	"movzbl",	USHORT,	"movzwl",	UNSIGNED,	"movl",	ULONG,	"movl",	-1, ""	};char *toreg( TWORD type ){	struct type_move *p;	for ( p=toreg_strs; p->fromtype > 0; p++)		if (p->fromtype == type) return(p->tostrng);	/* type not found, must be a pointer type */	return("movl");}/* tbl */int cc_main( int argc, char *argv[] )	{#ifdef BUFSTDERR	char errbuf[BUFSIZ];	setbuf(stderr, errbuf);#endif	return(mainp1( argc, argv ));	}struct sw heapsw[SWITSZ];	/* heap for switches */void genswitch(register struct sw *p, int n)	{	/*	p points to an array of structures, each consisting		of a constant value and a label.		The first is >=0 if there is a default label;		its value is the label number		The entries p[1] to p[n] are the nontrivial cases		*/	register i;	register CONSZ j, range;	register dlab, swlab;	range = p[n].sval-p[1].sval;	if( range>0 && range <= 3*n && n>=4 ){ /* implement a direct switch */		swlab = getlab();		dlab = p->slab >= 0 ? p->slab : getlab();		/* already in r0 */		printf("	casel	r0,$%ld,$%ld\n", p[1].sval, range);		printf("L%d:\n", swlab);		for( i=1,j=p[1].sval; i<=n; j++) {			printf("	.word	L%d-L%d\n", (j == p[i].sval ? ((j=p[i++].sval), p[i-1].slab) : dlab),				swlab);			}		if( p->slab >= 0 ) branch( dlab );		else printf("L%d:\n", dlab);		return;		}	if( n>8 ) {	/* heap switch */		heapsw[0].slab = dlab = p->slab >= 0 ? p->slab : getlab();		makeheap(p, n, 1);	/* build heap */		walkheap(1, n);	/* produce code */		if( p->slab >= 0 )			branch( dlab );		else			printf("L%d:\n", dlab);		return;	}	/* debugging code */	/* out for the moment	if( n >= 4 ) werror( "Inefficient switch: %d, %d", n, (int) (range/n) );	*/	/* simple switch code */	for( i=1; i<=n; ++i ){		/* already in r0 */		printf( "	cmpl	r0,$" );		printf( CONFMT, p[i].sval );		printf( "\n	jeql	L%d\n", p[i].slab );		}	if( p->slab>=0 ) branch( p->slab );	}void makeheap( register struct sw *p, int m, int n )	{	register int q;	q = select(m);	heapsw[n] = p[q];	if( q>1 ) makeheap(p, q-1, 2*n);	if( q<m ) makeheap(p+q, m-q, 2*n+1);	}int select( int m )	{	register int l,i,k;	for(i=1; ; i*=2)		if( (i-1) > m ) break;	l = ((k = i/2 - 1) + 1)/2;	return( l + (m-k < l ? m-k : l));	}void walkheap( int start, int limit ){	int label;	if( start > limit ) return;	printf("	cmpl	r0,$%d\n",  heapsw[start].sval);	printf("	jeql	L%d\n", heapsw[start].slab);	if( (2*start) > limit ) {		printf("	jbr 	L%d\n", heapsw[0].slab);		return;	}	if( (2*start+1) <= limit ) {		label = getlab();		printf("	jgtr	L%d\n", label);	} else		printf("	jgtr	L%d\n", heapsw[0].slab);	walkheap( 2*start, limit);	if( (2*start+1) <= limit ) {		printf("L%d:\n", label);		walkheap( 2*start+1, limit);	}}