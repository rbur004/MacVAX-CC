#ifndef lintstatic char *sccsid = "@(#)cpp.c	3.2	ULTRIX	5/13/87";#endif /************************************************************************ * *			Modification History * *	David Metsky, 06-May-87 * 006- Upped the nuber of include directories (-I) from 10 to 32. *	Added the defined constant INCLDIR, set to 32. * *	David Metsky, 08-Jan-87 * 005- Upped size of SBSIZE from 20*BUFSIZ to 30*BUFSIZ. * *	Lu  Anne Van de Pas, 01-Apr-86 * 004- Add support for -Em switch to output include file dependencies  *	and increase symsiz from 2000 to 2500  * *	David L Ballenger, 27-Nov-1984 * 003-	Increase value of NPREDEF so that more -D and -U options can be *	used. * *	Stephen Reilly, 29-Dec-83 * 002- Add copyright date * *	APS, 27-Dec-83 * 001- Added new defaults symbols bsd4_2 and ultrix * ***********************************************************************//************************************************************************ *									* *			Copyright (c) 1983 by				* *		Digital Equipment Corporation, Maynard, MA		* *			All rights reserved.				* *									* *   This software is furnished under a license and may be used and	* *   copied  only  in accordance with the terms of such license and	* *   with the  inclusion  of  the  above  copyright  notice.   This	* *   software  or  any  other copies thereof may not be provided or	* *   otherwise made available to any other person.  No title to and	* *   ownership of the software is hereby transferred.			* *									* *   This software is  derived  from  software  received  from  the	* *   University    of   California,   Berkeley,   and   from   Bell	* *   Laboratories.  Use, duplication, or disclosure is  subject  to	* *   restrictions  under  license  agreements  with  University  of	* *   California and with AT&T.						* *									* *   The information in this software is subject to change  without	* *   notice  and should not be construed as a commitment by Digital	* *   Equipment Corporation.						* *									* *   Digital assumes no responsibility for the use  or  reliability	* *   of its software on equipment which is not supplied by Digital.	* *									* ************************************************************************/#ifdef FLEXNAMES#define	NCPS	128#else#define	NCPS	8#endif#include <stdio.h>#include <stdlib.h>#include <stdarg.h>#include <string.h>#include <ctype.h>#include <unix.h>		/* AJW */#include "cpp_cpp.h"	/* DWG */#include "cpp_cpy.h"#include "cpp_memoryutils.h"#include "UnixToMacPath.h"/* C command/* written by John F. Reiser/* July/August 1978*/#define STATIC#define STDIN 0#define STDOUT 1#define STDERR 2#define READ 0#define WRITE 1#define SALT '#'#ifdef BUFSIZ#undef BUFSIZ#endif #ifndef BUFSIZ#define BUFSIZ 4096	/* careful changing this -- SBSIZE depends on it */#endifchar *pbeg,*pbuf,*pend;char *outp,*inp;char *newp;char cpp_cinit;/* some code depends on whether characters are sign or zero extended *//*	#if '\377' < 0		not used here, old cpp doesn't understand */#if pdp11 | vax | mc68000 | macVax#define COFF 128#else#define COFF 0#endif#if gcos #define ALFSIZ 512	/* alphabet size */# else#define ALFSIZ 256	/* alphabet size */# endifchar macbit[ALFSIZ+11];char toktyp[ALFSIZ];#define BLANK 1#define IDENT 2#define NUMBR 3/* a superimposed code is used to reduce the number of calls to the/* symbol table lookup routine.  (if the kth character of an identifier/* is 'a' and there are no macro names whose kth character is 'a'/* then the identifier cannot be a macro name, hence there is no need/* to look in the symbol table.)  'scw1' enables the test based on/* single characters and their position in the identifier.  'scw2'/* enables the test based on adjacent pairs of characters and their/* position in the identifier.  scw1 typically costs 1 indexed fetch,/* an AND, and a jump per character of identifier, until the identifier/* is known as a non-macro name or until the end of the identifier./* scw1 is inexpensive.  scw2 typically costs 4 indexed fetches,/* an add, an AND, and a jump per character of identifier, but it is also/* slightly more effective at reducing symbol table searches./* scw2 usually costs too much because the symbol table search is/* usually short; but if symbol table search should become expensive,/* the code is here./* using both scw1 and scw2 is of dubious value.*/#define scw1 1#define scw2 0#if scw2char t21[ALFSIZ],t22[ALFSIZ],t23[ALFSIZ+NCPS];#endif#if scw1#define b0 1#define b1 2#define b2 4#define b3 8#define b4 16#define b5 32#define b6 64#define b7 128#endif#define IB 1#define SB 2#define NB 4#define CB 8#define QB 16#define WB 32char fastab[ALFSIZ];char slotab[ALFSIZ];char *ptrtab;#define isslo (ptrtab==(slotab+COFF))#define isid(a)  ((fastab+COFF)[a]&IB)#define isspc(a) (ptrtab[a]&SB)#define isnum(a) ((fastab+COFF)[a]&NB)#define iscom(a) ((fastab+COFF)[a]&CB)#define isquo(a) ((fastab+COFF)[a]&QB)#define iswarn(a) ((fastab+COFF)[a]&WB)#define eob(a) ((a)>=pend)#define bob(a) (pbeg>=(a))# define cputc(a,b)	if(!flslvl) putc(a,b)char buffer[NCPS+BUFSIZ+BUFSIZ+NCPS];# define SBSIZE 30*BUFSIZ		/* std = 12000, wnj aug 1979 */					/* should be in units of BUFSIZ */					/* since that is how it is used */					/* was 60000 in 4.2, 80000 4.3 */					/* is now 20*4096 in ULTRIX 1.2 */					/* is now 30*4096 in ULTRIX 2.0 */					char	*sbf;	    /* AJW: points to buffer of SBSIZE bytes */char	*savch;/* dnm - 006 */# define INCLDIR 32# define DROP 0xFE	/* special character not legal ASCII or EBCDIC */# define WARN DROP# define SAME 0# define MAXINC 10# define MAXFRE 14	/* max buffers of macro pushback */# define MAXFRM 31	/* max number of formals/actuals to a macro */static char warnc;int mactop,fretop;char *cpp_instack[MAXFRE],*bufstack[MAXFRE],*endbuf[MAXFRE];int plvl;	/* parenthesis level during scan for macro actuals */int maclin;	/* line number of macro call requiring actuals */char *macfil;	/* file name of macro call requiring actuals */char *macnam;	/* name of macro requiring actuals */int maclvl;	/* # calls since last decrease in nesting level */char *macforw;	/* pointer which must be exceeded to decrease nesting level */int macdam;	/* offset to macforw due to buffer shifting */#if tgpint tgpscan;	/* flag for dump(); */#endifSTATIC	int	inctop[MAXINC];STATIC	char	*fnames[MAXINC];STATIC	char	*dirnams[MAXINC];	/* actual directory of #include files */STATIC	FILE *fins[MAXINC];STATIC	int	cpp_lineno[MAXINC];				/* 006 - dnm */STATIC	char	*dirs[INCLDIR];	/* -I and <> directories */STATIC	FILE	*fin;STATIC	FILE	*fout;STATIC	int	nd;STATIC	int	cpp_pflag;	/* don't put out lines "# 12 foo.c" */int	passcom;	/* don't delete comments */STATIC	int rflag;	/* allow macro recursion */STATIC  int mflag;	/* generate makefile dependencies */STATIC  char *infile;	/* name of .o file to build dependencies from */STATIC  FILE *mout;	/* file to place dependencies on */#define START 1#define CONT 2#define BACK 3STATIC	int	ifno;# define NPREDEF 100STATIC	char *prespc[NPREDEF];STATIC	char **predef;STATIC	char *punspc[NPREDEF];STATIC	char **prund;STATIC	int	exfail;struct symtab *lastsym;#include <setjmp.h>static jmp_buf env;		// DG - doesn't rely on being auto initialised.# undef exit# define exit(S)	fclose(fin);longjmp(env, S)			//DG - added fclose.# if gcos# define main	mainpp# define open(S,D)	fileno(fopen(S, "r"))# define close(F)	fclose(_f[F])extern FILE *_f[];# define symsiz 500# else# define symsiz 2500		/* std = 500, wnj aug 1979 */# endifSTATIC	struct symtab *cpp_stab; /* symsiz AJW */STATIC	struct symtab *defloc;STATIC	struct symtab *udfloc;STATIC	struct symtab *incloc;STATIC	struct symtab *ifloc;STATIC	struct symtab *elsloc;STATIC	struct symtab *eifloc;STATIC	struct symtab *ifdloc;STATIC	struct symtab *ifnloc;STATIC	struct symtab *ysysloc;STATIC	struct symtab *varloc;STATIC	struct symtab *lneloc;STATIC	struct symtab *ulnloc;STATIC	struct symtab *uflloc;STATIC	int	trulvl;STATIC	int	flslvl;STATIC  int gExitTime;#define rindex strrchr#define SYMSIZE (symsiz * sizeof(struct symtab))void sayline( int where ){	if (mflag && where==START) fprintf(mout, "%s: %s\n", infile, fnames[ifno]);	if (cpp_pflag==0) fprintf(fout,"# %d \"%s\"\n", cpp_lineno[ifno], fnames[ifno]);}/* data structure guide/*/* most of the scanning takes place in the buffer:/*/*  (low address)                                             (high address)/*  pbeg                           pbuf                                 pend/*  |      <-- BUFSIZ chars -->      |         <-- BUFSIZ chars -->        |/*  _______________________________________________________________________/* |_______________________________________________________________________|/*          |               |               |/*          |<-- waiting -->|               |<-- waiting -->/*          |    to be      |<-- current -->|    to be/*          |    written    |    token      |    scanned/*          |               |               |/*          outp            inp             p/*/*  *outp   first char not yet written to output file/*  *inp    first char of current token/*  *p      first char not yet scanned/*/* macro expansion: write from *outp to *inp (chars waiting to be written),/* ignore from *inp to *p (chars of the macro call), place generated/* characters in front of *p (in reverse order), update pointers,/* resume scanning./*/* symbol table pointers point to just beyond the end of macro definitions;/* the first preceding character is the number of formal parameters./* the appearance of a formal in the body of a definition is marked by/* 2 chars: the char WARN, and a char containing the parameter number./* the first char of a definition is preceded by a zero character./*/* when macro expansion attempts to back up over the beginning of the/* buffer, some characters preceding *pend are saved in a side buffer,/* the address of the side buffer is put on 'cpp_instack', and the rest/* of the main buffer is moved to the right.  the end of the saved buffer/* is kept in 'endbuf' since there may be nulls in the saved buffer./*/* similar action is taken when an 'include' statement is processed,/* except that the main buffer must be completely emptied.  the array/* element 'inctop[ifno]' records the last side buffer saved when/* file 'ifno' was included.  these buffers remain dormant while/* the file is being read, and are reactivated at end-of-file./*/* cpp_instack[0 : mactop] holds the addresses of all pending side buffers./* cpp_instack[inctop[ifno]+1 : mactop-1] holds the addresses of the side/* buffers which are "live"; the side buffers cpp_instack[0 : inctop[ifno]]/* are dormant, waiting for end-of-file on the current file./*/* space for side buffers is obtained from 'savch' and is never returned./* bufstack[0:fretop-1] holds addresses of side buffers which/* are available for use.*/# if gcosstatic int dump_gmfirst = 0;#endifvoid dump( void )	{/* write part of buffer which lies between  outp  and  inp ./* this should be a direct call to 'write', but the system slows to a crawl/* if it has to do an unaligned copy.  thus we buffer.  this silly loop/* is 15% of the total time, thus even the 'putc' macro is too slow.*/	register char *p1,*p2; register FILE *f;	if ((p1=outp)==inp || flslvl!=0) return;#if tgp#define MAXOUT 80	if (!tgpscan) {/* scan again to insure <= MAXOUT chars between linefeeds */		register char c,*pblank; char savc,stopc,brk;		tgpscan=1; brk=stopc=pblank=0; p2=inp; savc= *p2; *p2='\0';		while (c= *p1++) {			if (c=='\\') c= *p1++;			if (stopc==c) stopc=0;			else if (c=='"' || c=='\'') stopc=c;			if (p1-outp>MAXOUT && pblank!=0) {				*pblank++='\n'; inp=pblank; dump(); brk=1; pblank=0;			}			if (c==' ' && stopc==0) pblank=p1-1;		}		if (brk) sayline(CONT);		*p2=savc; inp=p2; p1=outp; tgpscan=0;	}#endif	f=fout;# if gcos/* filter out "$ program c" card if first line of input *//* gmatch is a simple pattern matcher in the GCOS Standard Library */{		if (!dump_gmfirst) {		++dump_gmfirst;		if (gmatch(p1, "^$*program[ \t]*c*"))			p1 = strdex(p1, '\n');	}}# endif	/* Performance improvement - skip the writes if doing makefile - rr */	if (!mflag) while (p1<inp) putc(*p1++,f);	outp = inp;}char *refill( register char *p )	{/* dump buffer.  save chars from inp to p.  read into buffer at pbuf,/* contiguous with p.  update pointers, return new p.*/	register char *np,*op; register int ninbuf;	dump(); np=pbuf-(p-inp); op=inp;	if (bob(np+1)) {pperror("Token too long"); np=pbeg; p=inp+BUFSIZ;}	macdam += np-inp; outp=inp=np;	while (op<p) *np++= *op++;	p=np;	for (;;) {		if (mactop>inctop[ifno]) /* retrieve hunk of pushed-back macro text */			{			op=cpp_instack[--mactop]; np=pbuf;			do { while (*np++= *op++); } while (op<endbuf[mactop]); pend=np-1;			/* make buffer space avail for 'include' processing */			if (fretop<MAXFRE) bufstack[fretop++]=cpp_instack[mactop];			return(p);			}		else  /* get more text from file(s) */			{			maclvl=0;#if !macVax			if (fin == stdin)				{				if (0<(ninbuf=read(STDIN, (unsigned char *) pbuf,BUFSIZ)))					{					pend=pbuf+ninbuf; *pend='\0';					return(p);					}				}			else#endif				{				if (0<(ninbuf=fread((unsigned char *) pbuf,1,BUFSIZ,fin)))					{					pend=pbuf+ninbuf; *pend='\0';					return(p);					}				}			/* end of #include file */			if (ifno==0)  /* end of input */				{				if (plvl!=0)					{					int n=plvl, tlin=cpp_lineno[ifno];					char *tfil=fnames[ifno];					cpp_lineno[ifno]=maclin; fnames[ifno]=macfil;					pperror("%s: Unterminated macro call",macnam);					cpp_lineno[ifno]=tlin; fnames[ifno]=tfil;					np=p; *np++='\n';			/* shut off unterminated quoted string */										while (--n>=0)						*np++=')';	/* supply missing parens */										pend=np; *np='\0'; if (plvl<0) plvl=0;										return(p);					}				if (trulvl || flslvl)					pperror("Missing endif");				inp=p; dump(); exit(exfail);				}					fclose(fin);			fin = fins[--ifno];			dirs[0]=dirnams[ifno];			sayline(BACK);			}		}}#define BEG 0#define LF 1static int cotoken_state = BEG;char *cotoken( register char *p )	{	register int c,i; char quoc;	if (cotoken_state!=BEG) goto prevlf;for (;;) {again:	while (!isspc(*p++));	switch (*(inp=p-1)) {	case 0: {		if (eob(--p)) {p=refill(p); goto again;}		else ++p; /* ignore null byte */	} break;	case '|': case '&': for (;;) {/* sloscan only */		if (*p++== *inp) break;		if (eob(--p)) p=refill(p);		else break;	} break;	case '=': case '!': for (;;) {/* sloscan only */		if (*p++=='=') break;		if (eob(--p)) p=refill(p);		else break;	} break;	case '<': case '>': for (;;) {/* sloscan only */		if (*p++=='=' || p[-2]==p[-1]) break;		if (eob(--p)) p=refill(p);		else break;	} break;	case '\\': for (;;) {		if (*p++=='\n') {++cpp_lineno[ifno]; break;}		if (eob(--p)) p=refill(p);		else {++p; break;}	} break;	case '/': for (;;) {		if (*p++=='*') {/* comment */			if (!passcom) {inp=p-2; dump(); ++flslvl;}			for (;;) {				while (!iscom(*p++));				if (p[-1]=='*') for (;;) {					if (*p++=='/') goto endcom;					if (eob(--p)) {						if (!passcom) {inp=p; p=refill(p);}						else if ((p-inp)>=BUFSIZ) {/* split long comment */							inp=p; p=refill(p);	/* last char written is '*' */							cputc('/',fout);	/* terminate first part */							/* and fake start of 2nd */							outp=inp=p-=3; *p++='/'; *p++='*'; *p++='*';						} else p=refill(p);					} else break;				} else if (p[-1]=='\n') {					++cpp_lineno[ifno]; if (!passcom) putc('\n',fout);				} else if (eob(--p)) {					if (!passcom) {inp=p; p=refill(p);}					else if ((p-inp)>=BUFSIZ) {/* split long comment */						inp=p; p=refill(p);						cputc('*',fout); cputc('/',fout);						outp=inp=p-=2; *p++='/'; *p++='*';					} else p=refill(p);				} else ++p; /* ignore null byte */			}		endcom:			if (!passcom) {outp=inp=p; --flslvl; goto again;}			break;		}		if (eob(--p)) p=refill(p);		else break;	} break;	case '"': case '\'': {		quoc=p[-1];		for (;;) {			while (!isquo(*p++));			if (p[-1]==quoc) break;			if (p[-1]=='\n') {--p; break;} /* bare \n terminates quotation */			if (p[-1]=='\\') for (;;) {				if (*p++=='\n') {++cpp_lineno[ifno]; break;} /* escaped \n ignored */				if (eob(--p)) p=refill(p);				else {++p; break;}			} else if (eob(--p)) p=refill(p);			else ++p;	/* it was a different quote character */		}	} break;	case '\n': {		++cpp_lineno[ifno]; if (isslo) {cotoken_state=LF; return(p);}prevlf:		cotoken_state=BEG;		for (;;) {			if (*p++=='#') return(p);			if (eob(inp= --p)) p=refill(p);			else goto again;		}	} break;	case '0': case '1': case '2': case '3': case '4':	case '5': case '6': case '7': case '8': case '9':	for (;;) {		while (isnum(*p++));		if (eob(--p)) p=refill(p);		else break;	} break;	case 'A': case 'B': case 'C': case 'D': case 'E':	case 'F': case 'G': case 'H': case 'I': case 'J':	case 'K': case 'L': case 'M': case 'N': case 'O':	case 'P': case 'Q': case 'R': case 'S': case 'T':	case 'U': case 'V': case 'W': case 'X': case 'Y':	case 'Z': case '_':	case 'a': case 'b': case 'c': case 'd': case 'e':	case 'f': case 'g': case 'h': case 'i': case 'j':	case 'k': case 'l': case 'm': case 'n': case 'o':	case 'p': case 'q': case 'r': case 's': case 't':	case 'u': case 'v': case 'w': case 'x': case 'y':	case 'z':#if scw1#define tmac1(c,bit) if (!xmac1(c,bit,&)) goto nomac#define xmac1(c,bit,op) ((macbit+COFF)[c] op (bit))#else#define tmac1(c,bit)#define xmac1(c,bit,op)#endif#if scw2#define tmac2(c0,c1,cpos) if (!xmac2(c0,c1,cpos,&)) goto nomac#define xmac2(c0,c1,cpos,op)\	((macbit+COFF)[(t21+COFF)[c0]+(t22+COFF)[c1]] op (t23+COFF+cpos)[c0])#else#define tmac2(c0,c1,cpos)#define xmac2(c0,c1,cpos,op)#endif	if (flslvl) goto nomac;	for (;;) {		c= p[-1];                          tmac1(c,b0);		i= *p++; if (!isid(i)) goto endid; tmac1(i,b1); tmac2(c,i,0);		c= *p++; if (!isid(c)) goto endid; tmac1(c,b2); tmac2(i,c,1);		i= *p++; if (!isid(i)) goto endid; tmac1(i,b3); tmac2(c,i,2);		c= *p++; if (!isid(c)) goto endid; tmac1(c,b4); tmac2(i,c,3);		i= *p++; if (!isid(i)) goto endid; tmac1(i,b5); tmac2(c,i,4);		c= *p++; if (!isid(c)) goto endid; tmac1(c,b6); tmac2(i,c,5);		i= *p++; if (!isid(i)) goto endid; tmac1(i,b7); tmac2(c,i,6);		                                                tmac2(i,0,7);		while (isid(*p++));		if (eob(--p)) {refill(p); p=inp+1; continue;}		goto lokid;	endid:		if (eob(--p)) {refill(p); p=inp+1; continue;}		tmac2(p[-1],0,-1+(p-inp));	lokid:		slookup(inp,p,0); if (newp) {p=newp; goto again;}		else break;	nomac:		while (isid(*p++));		if (eob(--p)) {p=refill(p); goto nomac;}		else break;	} break;	} /* end of switch */		if (isslo) return(p);} /* end of infinite loop */}char *skipbl( register char *p )	{/* get next non-blank token */	do {outp=inp=p; p=cotoken(p);} while ((toktyp+COFF)[*inp]==BLANK);	return(p);	}char *unfill( register char *p )	{/* take <= BUFSIZ chars from right end of buffer and put them on cpp_instack ./* slide rest of buffer to the right, update pointers, return new p.*/	register char *np,*op; register int d;	if (mactop>=MAXFRE) {		pperror("%s: Too much pushback",macnam);		p=inp=pend; dump();	/* begin flushing pushback */		while (mactop>inctop[ifno]) {p=refill(p); p=inp=pend; dump();}	}	if (fretop>0) np=bufstack[--fretop];	else {		np=savch; savch+=BUFSIZ;		if (savch>=sbf+SBSIZE) {pperror("No space"); exit(exfail);}		*savch++='\0';	}	cpp_instack[mactop]=np; op=pend-BUFSIZ; if (op<p) op=p;	for (;;) {while (*np++= *op++); if (eob(op)) break;} /* out with old */	endbuf[mactop++]=np;	/* mark end of saved text */	np=pbuf+BUFSIZ; op=pend-BUFSIZ; pend=np; if (op<p) op=p;	while (outp<op) *--np= *--op; /* slide over new */	if (bob(np)) pperror("Token too long");	d=np-outp; outp+=d; inp+=d; macdam+=d; return(p+d);}char *doincl( register char *p )	{	register int filok,inctype;	register char *cp; register char **dirp,*nfil;	char filname[BUFSIZ];#if macVax	char unixPath[BUFSIZ];#endif	p=skipbl(p); cp=filname;	if (*inp++=='<') {/* special <> syntax */		inctype=1;		++flslvl;	/* prevent macro expansion */		for (;;) {			outp=inp=p; p=cotoken(p);			if (*inp=='\n') {--p; *cp='\0'; break;}			if (*inp=='>') {      *cp='\0'; break;}# ifdef gimpel			if (*inp=='.' && !intss()) *inp='#';# endif			while (inp<p) *cp++= *inp++;		}		--flslvl;	/* reenable macro expansion */	} else if (inp[-1]=='"') {/* regular "" syntax */		inctype=0;# ifdef gimpel		while (inp<p) {if (*inp=='.' && !intss()) *inp='#'; *cp++= *inp++;}# else		while (inp<p) *cp++= *inp++;# endif		if (*--cp=='"') *cp='\0';	} else {pperror("Bad include syntax",0); inctype=2;}	/* flush current file to \n , then write \n */	++flslvl; do {outp=inp=p; p=cotoken(p);} while (*inp!='\n'); --flslvl;	inp=p; dump(); if (inctype==2) return(p);	/* look for included file */	if (ifno+1 >=MAXINC) {		pperror("Unreasonable include nesting",0); return(p);	}	if((nfil=savch)>sbf+SBSIZE-BUFSIZ) {pperror("No space"); exit(exfail);}	filok=0;	for (dirp=dirs+inctype; *dirp; ++dirp) {		if (#if gcos				strdex(filname, '/') ||#else#if macVax				(filname[0]!=':' && strdex(filname, ':') ) ||#endif				filname[0]=='/'# endif				)					{#if macVax										if (isUnixPath( filname ) )						{						strcpy( unixPath, filname );						UnixToMacPath( filname, unixPath );							}#endif /* macVax */								strcpy(nfil,filname);					}		else {# if macVax			if ( isUnixPath( *dirp ) )				{				strcpy( unixPath, *dirp );				UnixToMacPath( nfil, unixPath );				}			else				strcpy( nfil, *dirp );						if ( !isUnixPath( filname ) )				{				if ( filname[0] != ':' )					strcat( nfil, ":" );				}			else				{					strcpy( unixPath, filname );					UnixToMacPath( filname, unixPath ); 				}# else			strcpy(nfil,*dirp);			# if unix			if (**dirp != '\0')				strcat(nfil,"/");# endif# endif#ifdef ibm#ifndef gimpel			strcat(nfil,".");#endif#endif			strcat(nfil,filname);		}		if (NULL != (fins[ifno+1]=fopen(nfil,"r"))) {			filok=1; fin=fins[++ifno]; break;		}	}	if (filok==0) pperror("Can't find include file \"%s\"",filname);	else {		cpp_lineno[ifno]=1; fnames[ifno]=cp=nfil; while (*cp++); savch=cp;		dirnams[ifno]=dirs[0]=trmdir(copy(nfil));		sayline(START);		/* save current contents of buffer */		while (!eob(p)) p=unfill(p);		inctop[ifno]=mactop;	}	return(p);}int equfrm( register char *a, register char *p1, register char *p2 )	{	register char c; register int flag;	c= *p2; *p2='\0';	flag=strcmp(a,p1); *p2=c; return(flag==SAME);	}char *dodef( register char *p )	{/* process '#define' */	register char *pin,*psav,*cf;	char **pf,**qf; register int b;int c,params;	register struct symtab *np;	char *oldval,*oldsavch;	char *formal[MAXFRM]; /* formal[n] is name of nth formal */	char formtxt[BUFSIZ]; /* space for formal names */	if (savch>sbf+SBSIZE-BUFSIZ) {pperror("Too much defining"); return(p);}	oldsavch=savch; /* to reclaim space if redefinition */	++flslvl; /* prevent macro expansion during 'define' */	p=skipbl(p); pin=inp;	if ((toktyp+COFF)[*pin]!=IDENT) {		ppwarn("Illegal macro name"); while (*inp!='\n') p=skipbl(p); return(p);	}	np=slookup(pin,p,1);	if (oldval=np->value) savch=oldsavch;	/* was previously defined */	b=1; cf=pin;	while (cf<p) {/* update macbit */		c= *cf++; xmac1(c,b,|=); b=(b+b)&0xFF;		if (cf!=p) xmac2(c,*cf,-1+(cf-pin),|=);		else xmac2(c,0,-1+(cf-pin),|=);	}	params=0; outp=inp=p; p=cotoken(p); pin=inp;	if (*pin=='(') {/* with parameters; identify the formals */		cf=formtxt; pf=formal;		for (;;) {			p=skipbl(p); pin=inp;			if (*pin=='\n') {				--cpp_lineno[ifno]; --p; pperror("%s: Missing )",np->name); break;			}			if (*pin==')') break;			if (*pin==',') continue;			if ((toktyp+COFF)[*pin]!=IDENT) {				c= *p; *p='\0'; pperror("Bad formal: %s",pin); *p=c;			} else if (pf>= &formal[MAXFRM]) {				c= *p; *p='\0'; pperror("Too many formals: %s",pin); *p=c;			} else {				*pf++=cf; while (pin<p) *cf++= *pin++; *cf++='\0'; ++params;			}		}		if (params==0) --params; /* #define foo() ... */	} else if (*pin=='\n') {--cpp_lineno[ifno]; --p;}	/* remember beginning of macro body, so that we can	/* warn if a redefinition is different from old value.	*/	oldsavch=psav=savch;	for (;;) {/* accumulate definition until linefeed */		outp=inp=p; p=cotoken(p); pin=inp;		if (*pin=='\\' && pin[1]=='\n') {putc('\n',fout); continue;}	/* ignore escaped lf */		if (*pin=='\n') break;		if (params) {/* mark the appearance of formals in the definiton */			if ((toktyp+COFF)[*pin]==IDENT) {				for (qf=pf; --qf>=formal; ) {					if (equfrm(*qf,pin,p)) {						*psav++=qf-formal+1; *psav++=WARN; pin=p; break;					}				}			} else if (*pin=='"' || *pin=='\''						) {/* inside quotation marks, too */				char quoc= *pin;				for (*psav++= *pin++; pin<p && *pin!=quoc; ) {					while (pin<p && !isid(*pin)) *psav++= *pin++;					cf=pin; while (cf<p && isid(*cf)) ++cf;					for (qf=pf; --qf>=formal; ) {						if (equfrm(*qf,pin,cf)) {							*psav++=qf-formal+1; *psav++=WARN; pin=cf; break;						}					}					while (pin<cf) *psav++= *pin++;				}			}		}		while (pin<p) *psav++= *pin++;	}	*psav++=params; *psav++='\0';	if ((cf=oldval)!=NULL) {/* redefinition */		--cf;	/* skip no. of params, which may be zero */		while (*--cf);	/* go back to the beginning */		if (0!=strcmp(++cf,oldsavch)) {/* redefinition different from old */			--cpp_lineno[ifno]; ppwarn("%s redefined",np->name); ++cpp_lineno[ifno];			np->value=psav-1;		} else psav=oldsavch; /* identical redef.; reclaim space */	} else np->value=psav-1;	--flslvl; inp=pin; savch=psav; return(p);}#define fasscan() ptrtab=fastab+COFF#define sloscan() ptrtab=slotab+COFFchar *control( register char *p )	{/* find and handle preprocessor control lines */	register struct symtab *np;for (;;) {	fasscan(); p=cotoken(p); if (*inp=='\n') ++inp; dump();	sloscan(); p=skipbl(p);	*--inp=SALT; outp=inp; ++flslvl; np=slookup(inp,p,0); --flslvl;	if (np==defloc) {/* define */		if (flslvl==0) {p=dodef(p); continue;}	} else if (np==incloc) {/* include */		if (flslvl==0) {p=doincl(p); continue;}	} else if (np==ifnloc) {/* ifndef */		++flslvl; p=skipbl(p); np=slookup(inp,p,0); --flslvl;		if (flslvl==0 && np->value==0) ++trulvl;		else ++flslvl;	} else if (np==ifdloc) {/* ifdef */		++flslvl; p=skipbl(p); np=slookup(inp,p,0); --flslvl;		if (flslvl==0 && np->value!=0) ++trulvl;		else ++flslvl;	} else if (np==eifloc) {/* endif */		if (flslvl) {if (--flslvl==0) sayline(CONT);}		else if (trulvl) --trulvl;		else pperror("If-less endif",0);	} else if (np==elsloc) {/* else */		if (flslvl) {			if (--flslvl!=0) ++flslvl;			else {++trulvl; sayline(CONT);}		}		else if (trulvl) {++flslvl; --trulvl;}		else pperror("If-less else",0);	} else if (np==udfloc) {/* undefine */		if (flslvl==0) {			++flslvl; p=skipbl(p); slookup(inp,p,DROP); --flslvl;		}	} else if (np==ifloc) {/* if */#if tgp		pperror("IF not implemented, true assumed", 0);		if (flslvl==0) ++trulvl; else ++flslvl;#else		newp=p;		if (flslvl==0 && yy1parse()) ++trulvl; else ++flslvl;		p=newp;#endif	} else if (np==lneloc) {/* line */		if (flslvl==0 && cpp_pflag==0) {			char *cp, *cp2;			outp=inp=p; *--outp='#'; while (*inp!='\n') p=cotoken(p);			cp = outp + 1;			while (isspace(*cp) && cp < inp)				cp++;			while (isdigit(*cp) && cp < inp)				cp++;			while (*cp != '"' && cp < inp)				cp++;			if (cp < inp) {				cp++;				cp2 = cp;				while (*cp2 != '"' && cp2 < inp)					cp2++;				fnames[ifno] = savestring(cp, cp2);			}			continue;		}	} else if (*++inp=='\n') outp=inp;	/* allows blank line after # */	else pperror("Undefined control",0);	/* flush to lf */	++flslvl; while (*inp!='\n') {outp=inp=p; p=cotoken(p);} --flslvl;}}char *savestring( register char *start, register char *finish )	{	register char *retbuf;	register char *cp;	retbuf = (char *) calloc(finish - start + 1, sizeof (char));	cpp_RememberAllocation( retbuf );	cp = retbuf;	while (start < finish)		*cp++ = *start++;	*cp = 0;	return(retbuf);	}struct symtab *stsym( register char *s )	{	char buf[BUFSIZ]; register char *p;	/* make definition look exactly like end of #define line */	/* copy to avoid running off end of world when param list is at end */	p=buf;	while (*p++ = *s++)		;			p=buf;	while (isid(*p++))		; /* skip first identifier */		if (*--p=='=')		{		*p++=' ';		while (*p++)			;		}	else 		{		s=" 1";		while (*p++= *s++)			;		}			pend = p;	*--p = '\n';	sloscan();	dodef( buf );	return( lastsym );	}struct symtab *ppsym( register char *s )	{/* kluge */	register struct symtab *sp;	cpp_cinit=SALT; *savch++=SALT; sp=stsym(s); --sp->name; cpp_cinit=0; return(sp);	}/* VARARGS1 */void pperror( char *s, ... )	{	va_list va;	int x,y;	va_start( va, s );	x = va_arg( va, int );	y = va_arg( va, int );	va_end( va );	if (fnames[ifno][0]) fprintf(stderr,			"\"%s\", line ",				 fnames[ifno]);	fprintf(stderr, "%d: ",cpp_lineno[ifno]);	fprintf(stderr, s, x, y);	fprintf(stderr,"\n");	++exfail;	}void yy1error( char *s, ... )	{	va_list va;	int a, b;	va_start( va, s );	a = va_arg( va, int );	b = va_arg( va, int );	va_end( va );	pperror(s,a,b);	}void ppwarn( char *s, ... )	{	va_list va;	int x;	int fail = exfail;	va_start( va, s );	x = va_arg( va, int );	va_end( va );	exfail = -1;	pperror(s,x);	exfail = fail;	}struct symtab *cpp_lookup( register char *namep, int enterf )	{	register char *np, *snp;	register int c, i; int around;	register struct symtab *sp;	/* namep had better not be too long (currently, <=NCPS chars) */	np=namep; around=0; i=cpp_cinit;	while (c= *np++) i += i+c; c=i;	/* c=i for register usage on pdp11 */	c %= symsiz; if (c<0) c += symsiz;	sp = &cpp_stab[c];	while (snp=sp->name)		{		np = namep;		while (*snp++ == *np) if (*np++ == '\0') {				if (enterf==DROP) {sp->name[0]= DROP; sp->value=0;}				return(lastsym=sp);			}		if (--sp < &cpp_stab[0])			if (around) {pperror("Too many defines", 0); exit(exfail);}			else {++around; sp = &cpp_stab[symsiz-1];}		}	if (enterf==1) sp->name=namep;	return(lastsym=sp);	}struct symtab *slookup( register char *p1, register char *p2, register int enterf)	{	register char *p3; char c2,c3; register struct symtab *np;		c2= *p2; *p2='\0';	/* mark end of token */		if ((p2-p1)>NCPS) p3=p1+NCPS; else p3=p2;		 c3= *p3; *p3='\0';	/* truncate to NCPS chars or less */	if (enterf==1) p1=copy(p1);	np=cpp_lookup(p1,enterf); *p3=c3; *p2=c2;	if (np->value!=0 && flslvl==0) newp=subst(p2,np);	else newp=0;	return(np);	}char *subst( register char *p, register struct symtab *sp )	{	static char match[]="%s: Argument mismatch";	/* Does not need reinitializing on 2nd pass */	register char *ca,*vp; register int params;	char *actual[MAXFRM]; /* actual[n] is text of nth actual   */	char actused[MAXFRM]; /* for newline processing in actuals */	char acttxt[BUFSIZ];  /* space for actuals */	register int  nlines = 0;	if (0==(vp=sp->value)) return(p);	if ((p-macforw)<=macdam) {		if (++maclvl>symsiz && !rflag) {			pperror("%s: Macro recursion",sp->name); return(p);		}	} else maclvl=0;	/* level decreased */	macforw=p; macdam=0;	/* new target for decrease in level */	macnam=sp->name;	dump();	if (sp==ulnloc) {		vp=acttxt; *vp++='\0';		sprintf(vp,"%d",cpp_lineno[ifno]); while (*vp++);	} else if (sp==uflloc) {		vp=acttxt; *vp++='\0';		sprintf(vp,"\"%s\"",fnames[ifno]); while (*vp++);	}	if (0!=(params= *--vp&0xFF)) {/* definition calls for params */		register char **pa;		ca=acttxt; pa=actual;		if (params==0xFF) params=1;	/* #define foo() ... */		sloscan(); ++flslvl; /* no expansion during search for actuals */		plvl= -1;		do p=skipbl(p); while (*inp=='\n');	/* skip \n too */		if (*inp=='(') {			maclin=cpp_lineno[ifno]; macfil=fnames[ifno];			for (plvl=1; plvl!=0; ) {				*ca++='\0';				for (;;) {					outp=inp=p; p=cotoken(p);					if (*inp=='(') ++plvl;					if (*inp==')' && --plvl==0) {--params; break;}					if (plvl==1 && *inp==',') {--params; break;}					while (inp<p) *ca++= *inp++;					if (ca> &acttxt[BUFSIZ])						pperror("%s: Actuals too long",sp->name);				}				if (pa>= &actual[MAXFRM]) ppwarn(match,sp->name);				else { actused[pa-actual]=0; *pa++=ca; }			}			nlines = cpp_lineno[ifno] - maclin;			cpp_lineno[ifno] = maclin; /* don't count newlines here */		}		if (params!=0) ppwarn(match,sp->name);		while (--params>=0) *pa++=""+1;	/* null string for missing actuals */		--flslvl; fasscan();	}	for (;;) {/* push definition onto front of input stack */		while (!iswarn(*--vp)) {			if (bob(p)) {outp=inp=p; p=unfill(p);}			*--p= *vp;		}		if (*vp==warnc) {/* insert actual param */			ca=actual[*--vp-1];			while (*--ca) {				if (bob(p)) {outp=inp=p; p=unfill(p);}				/* Actuals with newlines confuse line numbering */				if (*ca == '\n' && actused[*vp-1])					if (*(ca-1) == '\\') ca--;					else *--p = ' ';				else { *--p= *ca; if (*ca == '\n') nlines--; }			}			actused[*vp-1] = 1;		} else {			if (nlines > 0 )				while (nlines-- > 0)					*--p = '\n';			break;		}	}	outp=inp=p;	return(p);	}char *trmdir( register char *s )	{	register char *p = s;# if macVax	while (*p++); --p; while (p>s && *--p!=':');# else	while (*p++); --p; while (p>s && *--p!='/');# endif# if unix	if (p==s) *p++='/';# endif	*p='\0';	return(s);	}STATIC char *copy( register char *s )	{	register char *old;	old = savch; while (*savch++ = *s++);	return(old);	}char *strdex( char *s, char c){	while (*s)		if (*s++==c)			return(--s);	return(0);}int yy1wrap( void )	{ return(1); }int cpp_main( int argc, char *argv[] ){	register int i,c;	register char *p;	char *tf,**cp2;	init_cpp_vars();	if (setjmp(env)) return (exfail);			p="_$ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";		i=0;		while (c= *p++) {			(fastab+COFF)[c] |= IB|NB|SB; (toktyp+COFF)[c]=IDENT;#if scw2			/* 53 == 63-10; digits rarely appear in identifiers,			/* and can never be the first char of an identifier.			/* 11 == 53*53/sizeof(macbit) .			*/			++i; (t21+COFF)[c]=(53*i)/11; (t22+COFF)[c]=i%11;#endif		}	p="0123456789.";		while (c= *p++) {(fastab+COFF)[c] |= NB|SB; (toktyp+COFF)[c]=NUMBR;}	p="\n\"'/\\";		while (c= *p++) (fastab+COFF)[c] |= SB;	p="\n\"'\\";		while (c= *p++) (fastab+COFF)[c] |= QB;	p="*\n"; while (c= *p++) (fastab+COFF)[c] |= CB;	(fastab+COFF)[warnc] |= WB;	(fastab+COFF)['\0'] |= CB|QB|SB|WB;	for ( i = ALFSIZ; --i >= 0; )		slotab[i] = fastab[i] | SB;	p=" \t\013\f\r";	/* note no \n;	\v not legal for vertical tab? */		while (c= *p++) (toktyp+COFF)[c]=BLANK;#if scw2	for ((t23+COFF)[i=ALFSIZ+7-COFF]=1; --i>=-COFF; )		if (((t23+COFF)[i]=(t23+COFF+1)[i]<<1)==0) (t23+COFF)[i]=1;#endif# if macVax	fnames[ifno=0] = ""; dirnams[0]=dirs[0]="";# endif# if unix	fnames[ifno=0] = ""; dirnams[0]=dirs[0]="/";# endif# if ibm	fnames[ifno=0] = "";# endif# if gcos	if (inquire(stdin, _TTY)) freopen("*src", "rt", stdin);# endif# if gimpel || gcos	fnames[ifno=0] = (char *)inquire(stdin, _FILENAME);	dirnams[0] = dirs[0] = trmdir(copy(fnames[0]));# endif	for(i=1; i<argc; i++)		{		switch(argv[i][0])			{			case '-':# if gcos			switch(toupper(argv[i][1])) { /* case-independent on GCOS */# else			switch(argv[i][1]) {# endif					case 'P': cpp_pflag++;				case 'E': 					/* -Em switch for makefile 					 * dependencies - vdp05					  */ 					if (argv[i][2] == 'm')	 	 					 	mflag++ ;					else 						continue;				case 'R': ++rflag; continue;				case 'C': passcom++; continue;				case 'D':					if (predef>prespc+NPREDEF) {						pperror("Too many -D options, ignoring %s",argv[i]);						continue;					}					/* ignore plain "-D" (no argument) */					if (*(argv[i]+2)) *predef++ = argv[i]+2;					continue;				case 'U':					if (prund>punspc+NPREDEF) {						pperror("Too many -U options, ignoring %s",argv[i]);						continue;					}					*prund++ = argv[i]+2;					continue;				case 'I':	/* dnm - 006 */					if (nd>(INCLDIR-2)) pperror("Excessive -I file (%s) ignored",argv[i]);					else dirs[nd++] = argv[i]+2;					continue;				case '\0': continue;				default: 					pperror("Unknown flag %s", argv[i]);					continue;				}			default:				if (fin==stdin) {					if (NULL == (fin=fopen(argv[i], "r"))) {	//DG Source file open command.						pperror("No source file %s",argv[i]); return(8);					}					fnames[ifno]=copy(argv[i]);					infile=copy(argv[i]);					dirs[0]=dirnams[ifno]=trmdir(argv[i]);# ifndef gcos/* too dangerous to have file name in same syntactic position   be input or output file depending on file redirections,   so force output to stdout, willy-nilly	[i don't see what the problem is.  jfr]*/				} else if (fout==stdout) {					if (NULL == (fout=fopen(argv[i], "w"))) {						pperror("Can't create %s", argv[i]); return(8);					} else fclose(stdout);# endif				} else pperror("Extraneous name %s", argv[i]);			}		}	if (fin == stdin)		setvbuf(fin, NULL, _IOLBF, 1024);	if (mflag) {		/*vdp05 makefile dependencies*/		if (infile==(char *)0) {			fprintf(stderr,				"No input file specified with -M flag\n");			return(8);		}		tf=(char *)rindex(infile, '.');		if (tf==0) {			fprintf(stderr, "Missing component name on %s\n",				infile);			return(8);		}		tf[1]='o';		tf=(char *)rindex(infile, '/');	//DG		if (tf!=(char *)0)			infile = tf + 1;		mout=fout;		if (NULL==(fout=fopen("/dev/null", "w"))) {			pperror("Can't open /dev/null");			return(8);		}	}	fins[ifno]=fin;	exfail = 0;		/* after user -I files here are the standard include libraries */# if unix	dirs[nd++] = "/usr/include";# endif# if gcos	dirs[nd++] = "cc/include";# endif# if ibm# ifndef gimpel	dirs[nd++] = "BTL$CLIB";# endif# endif# ifdef gimpel	dirs[nd++] = intss() ?  "SYS3.C." : "" ;# endif	/* dirs[nd++] = "/compool"; */	dirs[nd++] = 0;	defloc=ppsym("define");	udfloc=ppsym("undef");	incloc=ppsym("include");	elsloc=ppsym("else");	eifloc=ppsym("endif");	ifdloc=ppsym("ifdef");	ifnloc=ppsym("ifndef");	ifloc=ppsym("if");	lneloc=ppsym("line");	for (i=sizeof(macbit)/sizeof(macbit[0]); --i>=0; ) macbit[i]=0;# if macVax	ysysloc=stsym("unix");# endif# if unix	ysysloc=stsym("unix");# endif#if bsd4_2	ysysloc=stsym("bsd4_2");		/* aps001 */#endif#if ultrix	ysysloc=stsym("ultrix");		/* aps001 */#endif# if gcos	ysysloc=stsym ("gcos");# endif# if ibm	ysysloc=stsym ("ibm");# endif# if pdp11	varloc=stsym("pdp11");# endif# if vax	varloc=stsym("vax");# endif# if interdata	varloc=stsym ("interdata");# endif# if tss	varloc=stsym ("tss");# endif# if os	varloc=stsym ("os");# endif# if mert	varloc=stsym ("mert");# endif# if mc68000	varloc=stsym("mc68000");# endif# if sun	varloc=stsym("sun");# endif	ulnloc=stsym ("__LINE__");	uflloc=stsym ("__FILE__");	tf=fnames[ifno]; fnames[ifno]="command line"; cpp_lineno[ifno]=1;	cp2=prespc;	while (cp2<predef) stsym(*cp2++);	cp2=punspc;	while (cp2<prund) {		if (p=strdex(*cp2, '=')) *p++='\0';		cpp_lookup(*cp2++, DROP);	}	fnames[ifno]=tf;	pbeg=buffer+NCPS; pbuf=pbeg+BUFSIZ; pend=pbuf+BUFSIZ;	trulvl = 0; flslvl = 0;	cpp_lineno[0] = 1;	sayline(START);	outp=inp=pend;	control(pend);	return (exfail);}void init_cpp_vars( void ){#if macVax	// Zero some of the multitudinous number of globals in case this is	// our second pass.  DG	// Static function vars have been made global so that they can be	// reinitialised where necessary.	#	if gcos	dump_gmfirst = 0;#	endif	cotoken_state = BEG;		// Normal globals.	defloc = udfloc = incloc = ifloc = (void *) 0;	elsloc = eifloc = ifdloc = ifnloc = ysysloc = (void *) 0;	varloc = lneloc = ulnloc = uflloc = 0;		trulvl = flslvl = 0;	pbeg = pbuf = pend = nil;	outp = inp = nil;	newp = nil;	cpp_cinit = '\0';	memset(macbit, 0, ALFSIZ+11);	memset(toktyp, 0, ALFSIZ);	#if scw2	memset(t21, 0, ALFSIZ);	memset(t22, 0, ALFSIZ);	memset(t23, 0, ALFSIZ+NCPS);#endif	memset(fastab, 0, ALFSIZ);	memset(slotab, 0, ALFSIZ);	ptrtab = nil;	memset(buffer, 0, NCPS+BUFSIZ+BUFSIZ+NCPS);	mactop = fretop = 0;	memset(cpp_instack, 0, sizeof(char *) * MAXFRE);	memset(bufstack, 0, sizeof(char *) * MAXFRE);	memset(endbuf, 0, sizeof(char *) * MAXFRE);		plvl = maclin = maclvl = macdam = 0;	macfil = macnam = macforw = nil;#if tgp	tgpscan = 0;#endif	memset(inctop, 0, sizeof(int) * MAXINC);	memset(fnames, 0, sizeof(char *) * MAXINC);	memset(dirnams, 0, sizeof(char *) * MAXINC);	memset(fins, 0, sizeof(FILE *) * MAXINC);	memset(cpp_lineno, 0, sizeof(int) * MAXINC);	memset(dirs, 0, sizeof(char *) * INCLDIR);	cpp_pflag = passcom = 0;	rflag = mflag = 0;	infile = nil;	mout = nil;	ifno = 0;	memset(prespc, 0, sizeof(char *) * NPREDEF);	memset(punspc, 0, sizeof(char *) * NPREDEF);	predef = prund = nil;	lastsym = nil;	yy1lex_init_statics();	inityy1globals();#endif /* macVax */	// Now do some 'real' initialisation...	warnc = WARN;	fin = stdin;	fout = stdout;	nd = 1;	predef = prespc;	prund = punspc;	savch = sbf;	gExitTime = 0;	exfail = 0;	memset(sbf, 0, SBSIZE);	memset(cpp_stab, 0, SYMSIZE);}void init_cpp( void ){	sbf = (char *) calloc(1, SBSIZE);		cpp_stab = (struct symtab *) calloc(1, SYMSIZE);		cpp_StartAllocationTracker();}void kill_cpp( void ){	cpp_FreeRememberedAllocations();	free(sbf);	free(cpp_stab);}