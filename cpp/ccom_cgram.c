#include <string.h>#include "ccom_mfile1.h"#include "ccom_cgram.h"#include "ccom_common.h"#include "ccom_code.h"#include "ccom_local.h"#include "ccom_pftn.h"#include "ccom_optim.h"#include "ccom_scan.h"#include "ccom_trees.h"# define NAME 2# define STRING 3# define ICON 4# define FCON 5# define DCON 113# define PLUS 6# define MINUS 8# define MUL 11# define AND 14# define OR 17# define ER 19# define QUEST 21# define COLON 22# define ANDAND 23# define OROR 24# define ASOP 25# define RELOP 26# define EQUOP 27# define DIVOP 28# define SHIFTOP 29# define INCOP 30# define UNOP 31# define STROP 32# define TYPE 33# define CLASS 34# define STRUCT 35# define RETURN 36# define GOTO 37# define IF 38# define ELSE 39# define SWITCH 40# define BREAK 41# define CONTINUE 42# define WHILE 43# define DO 44# define FOR 45# define DEFAULT 46# define CASE 47# define SIZEOF 48# define ENUM 49# define LP 50# define RP 51# define LC 52# define RC 53# define LB 54# define RB 55# define CM 56# define SM 57# define ASSIGN 58# define ASM 59# define CONST 128# define VOLATILE 129#define yyclearin yychar = -1#define yyerrok yyerrflag = 0extern int yychar;extern short yyerrflag;#ifndef YYMAXDEPTH#define YYMAXDEPTH 150#endifYYSTYPE yylval, yyval;	static int fake;#ifndef FLEXNAMES	static char fakename[NCHNAM+1];#else#   define kFakeNameSize 24	static char fakename[kFakeNameSize];#endif# define YYERRCODE 256#if macVaxvoid cgram_init_statics( void ){	fake = 0;#   ifndef FLEXNAMES	memset (fakename, 0, (NCHNAM+1) * sizeof(char) );#   else	memset( fakename, 0, kFakeNameSize * sizeof(char) );#   endif /* FLEXNAMES */}#endif /* macVax */NODE *mkty( unsigned int t, int d, int s )	{	return( block( TYPE, NIL, NIL, t, d, s ) );	}NODE *bdty( int op, NODE *p, int v ){	register NODE *q;	q = block( op, p, NIL, INT, 0, INT );	switch( op ){	case UNARY MUL:		if (v == BCONST_PTR || v == BVOLATILE_PTR) {  /* vjh005 */		    q->in.typattr = v;		} else {		    q->in.typattr = 0;		}		break;	case UNARY CALL:		break;	case LB:		q->in.right = bcon(v);		break;	case NAME:		q->tn.rval = v;		break;	default:		cerror( "Bad bdty" );		}	return( q );	}void dstash( int n )	{ /* put n into the dimension table */	if( curdim >= DIMTABSZ-1 ){		cerror( "Dimension table overflow");		}	dimtab[ curdim++ ] = n;	}void savebc( void )	{	if( psavbc > & asavbc[BCSZ-4 ] ){		cerror( "Whiles, fors, etc. too deeply nested");		}	*psavbc++ = brklab;	*psavbc++ = contlab;	*psavbc++ = flostat;	*psavbc++ = swx;	flostat = 0;	}void resetbc( int mask )	{	swx = *--psavbc;	flostat = *--psavbc | (flostat&mask);	contlab = *--psavbc;	brklab = *--psavbc;	}void addcase( NODE *p )	{ /* add case to switch */	p = optim( p );  /* change enum to ints */	if( p->in.op != ICON ){		uerror( "Non-constant case expression");		return;		}	if( swp == swtab ){		uerror( "Case not in switch");		return;		}	if( swp >= &swtab[SWITSZ] ){		cerror( "Switch table overflow");		}	swp->sval = p->tn.lval;	deflab( swp->slab = getlab() );	++swp;	tfree(p);	}void adddef( void )	{ /* add default case to switch */	if( swtab[swx].slab >= 0 ){		uerror( "Duplicate default in switch");		return;		}	if( swp == swtab ){		uerror( "Default not inside switch");		return;		}	deflab( swtab[swx].slab = getlab() );	}void swstart( void )	{	/* begin a switch block */	if( swp >= &swtab[SWITSZ] ){		cerror( "Switch table overflow");		}	swx = swp - swtab;	swp->slab = -1;	++swp;	}void swend( void )	{ /* end a switch block */	register struct sw *swbeg, *p, *q, *r, *r1;	CONSZ temp;	int tempi;	swbeg = &swtab[swx+1];	/* sort */	r1 = swbeg;	r = swp-1;	while( swbeg < r ){		/* bubble largest to end */		for( q=swbeg; q<r; ++q ){			if( q->sval > (q+1)->sval ){				/* swap */				r1 = q+1;				temp = q->sval;				q->sval = r1->sval;				r1->sval = temp;				tempi = q->slab;				q->slab = r1->slab;				r1->slab = tempi;				}			}		r = r1;		r1 = swbeg;		}	/* it is now sorted */	for( p = swbeg+1; p<swp; ++p ){		if( p->sval == (p-1)->sval ){			uerror( "Duplicate case in switch, %d", tempi=p->sval );			return;			}		}	genswitch( swbeg-1, swp-swbeg );	swp = swbeg-1;	}extern short  yyexca[];# define YYNPROD 199# define YYLAST 1353extern short  yyact[];short  yyexca [] ={-1, 1,	0, -1,	2, 24,	11, 24,	35, 34,	49, 34,	50, 24,	57, 24,	-2, 0,-1, 9,	35, 34,	49, 34,	-2, 27,-1, 23,	56, 89,	57, 89,	-2, 7,-1, 28,	56, 88,	57, 88,	-2, 86,-1, 30,	56, 92,	57, 92,	-2, 87,-1, 35,	35, 34,	49, 34,	-2, 26,-1, 36,	35, 35,	49, 35,	-2, 31,-1, 67,	52, 42,	-2, 40,-1, 68,	52, 50,	-2, 48,-1, 106,	53, 100,	-2, 34,-1, 124,	33, 19,	34, 19,	35, 19,	49, 19,	128, 19,	129, 19,	-2, 14,-1, 295,	33, 17,	34, 17,	35, 17,	49, 17,	128, 17,	129, 17,	-2, 15,-1, 312,	33, 18,	34, 18,	35, 18,	49, 18,	128, 18,	129, 18,	-2, 16,	};extern short  yypact[];short  yyact []={ 226,  22, 277, 108, 246, 102,  99, 100,  77, 224,  91,  88,  32,  89,  32, 181,  90, 215,  32,  53, 113,  31,  32,  31,   7, 146, 162,  31,  59,  60, 115,  31,  93,  92, 111, 147, 227, 107, 236, 237, 241,  70, 245, 234, 235, 242, 243, 244, 248, 247,  94,  58,  95, 326, 125, 271,  15,  11,  86, 238,  26, 104,  26,  15,  11,  85,  26, 295,  52, 178,  26,  32,  65,  21,  15, 125,  15,  11, 325, 127,  31,  24,  28,  43, 312, 171, 222, 208, 148,   8,  10, 111, 319, 286,  43,  42, 163, 285, 167, 122,  34, 155, 156, 157, 158, 159, 160, 306,  47,  49, 281, 118, 280, 219, 179, 101, 106,  81, 218,  26, 173, 109,  82, 171, 176,  33,  62,  23, 114,  66, 313, 183, 184, 185, 187, 189, 191, 193, 195, 196, 198, 200, 202, 203, 204, 205, 206,  48,  50, 110, 148,  16,  17, 210, 116, 299, 175,  45,  16,  17, 177,  46, 163, 301,  45,  80, 265, 207,  46,  16,  17,  16,  17,  55,  79, 209, 172,  56, 265, 170, 129, 221, 126,  84,  76, 298, 164, 250, 212, 251, 151, 252, 153, 253, 117, 254, 223,  66, 255,  55, 256, 259, 257,  56,  55, 110, 217, 249,  56, 148, 154, 174, 169,  32, 152,  41,  38, 321, 304, 269, 263, 292,  31, 217, 270, 264, 213,  83,  75, 315, 261, 314, 291, 278, 267, 268, 290, 283, 273, 274, 275, 276, 289, 279, 260, 216, 266, 288, 293, 168, 287, 296, 164, 168,  61,  40, 303, 302, 239, 297,  11,  26, 216, 294,  19, 136,  30,  12, 112,  39,   9, 284,  30,  54, 300, 264,  30,  36, 211, 123,  37,  35, 132,  71, 128,  68,   4,  67,  78, 307, 308, 278, 310, 309, 240, 246, 102,  99, 100, 124, 121,  91,  63, 110,  89,  37, 133,  90, 134, 120, 149, 136,  57,  29, 316,  72, 322,  51, 220, 105, 278,  64, 323,  93,  92, 112,  69, 182, 132, 236, 237, 241, 180, 245, 234, 235, 242, 243, 244, 248, 247,  94, 119,  95,  74, 125, 225,   6,  73,  44, 238,   3, 104, 246, 102,  99, 100,   2, 166,  91,  97, 133,  89, 134,  96,  90, 136,  13,  14,   5, 103, 117,  27,  18,  20,  25, 233, 231, 232, 230, 228,  93,  92, 132, 135, 229,   1, 236, 237, 241,   0, 245, 234, 235, 242, 243, 244, 248, 247,  94,   0,  95,   0, 125,   0,   0, 101,   0, 238,   0, 104,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,   0,   0,  93,  92,   0,  15, 133,   0, 134,   0,   0, 136,   0,   0,   0,  93,  92,   0,   0,   0,  94,   0,  95,   0,   0,   0, 130, 101, 132, 135,   0, 104,   0,  94,   0,  95,   0,   0,   0,   0,   0,   0, 282,   0, 104,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,   0,   0,  93,  92,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 101,  93,  92,   0,   0,   0,  94,   0,  95,   0, 150,   0,   0, 101,   0,  16,  17, 104,   0,  94,   0,  95,  98, 102,  99, 100,   0, 239,  91, 201, 104,  89,   0,   0,  90,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,   0,   0,  93,  92,   0,   0, 133,   0, 134,   0,   0, 136,   0,   0, 138,  93,  92, 139,   0, 140,  94,   0,  95, 101,   0,   0, 130, 137, 132, 135, 199, 104,   0,  94,   0,  95, 101, 239,   0,   0,   0,   0,   0, 197, 104,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,   0,   0,  93,  92,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 101,  93,  92,   0,   0,   0,  94,   0,  95,   0,   0,   0,   0, 101,   0,   0, 194, 104,   0,  94,   0,  95,  98, 102,  99, 100,   0,   0,  91, 192, 104,  89,   0,   0,  90,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,   0,   0,  93,  92, 133,   0, 134,   0,   0, 136,   0,   0, 138,   0,   0,  93,  92, 140,   0,   0,  94,   0,  95, 101, 130, 137, 132, 135,   0,   0, 190, 104,   0,  94,   0,  95, 101,   0,   0,   0,   0,   0,   0, 188, 104,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,   0,   0,  93,  92,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 101,  93,  92,   0,   0,   0,  94,   0,  95,   0,   0,   0,   0, 101,   0,   0, 186, 104,   0,  94,   0,  95, 165,   0,   0,   0,  98, 102,  99, 100, 104,   0,  91,   0,   0,  89,   0,   0,  90,  98, 102,  99, 100,   0,   0,  91,   0,   0,  89,   0,   0,  90,   0,   0,  93,  92,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  93,  92,   0,   0, 101,  94,   0,  95,   0,  87,   0,  98, 102,  99, 100,   0, 104, 101,  94,   0,  95,  98, 102,  99, 100,   0,   0,  91,   0, 104,  89,   0,   0,  90,   0,   0,   0,   0,   0,  93,  92,   0,   0, 133,   0, 134,   0,   0, 136,  93,  92, 138,   0,   0, 139,   0, 140,  94, 143,  95, 141, 142, 144, 130, 137, 132, 135,  94, 104, 161, 101,   0,   0,   0,   0,   0,   0,   0, 104, 133,   0, 134,   0, 101, 136,   0,   0, 138, 324,   0, 139,   0, 140, 131, 143, 145, 141, 142, 144, 130, 137, 132, 135,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 101,   0, 320, 133,   0, 134,   0, 131, 136, 145, 101, 138,   0,   0, 139,   0, 140,   0, 143,   0, 141, 142, 144, 130, 137, 132, 135,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 133,   0, 134,   0,   0, 136,   0,   0, 138, 318,   0, 139,   0, 140, 131, 143, 145, 141, 142, 144, 130, 137, 132, 135,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 133,   0, 134,   0,   0, 136,   0, 317, 138,   0,   0, 139, 131, 140, 145, 143, 311, 141, 142, 144, 130, 137, 132, 135, 133,   0, 134,   0,   0, 136,   0,   0, 138,   0,   0, 139,   0, 140,   0, 143,   0, 141, 142, 144, 130, 137, 132, 135,   0, 133, 131, 134, 145,   0, 136,   0,   0, 138,   0,   0, 139,   0, 140,   0, 143,   0, 141, 142, 144, 130, 137, 132, 135,   0, 131, 305, 145,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 131, 272, 145, 133,   0, 134,   0,   0, 136,   0,   0, 138,   0,   0, 139,   0, 140,   0, 143,   0, 141, 142, 144, 130, 137, 132, 135, 133,   0, 134,   0,   0, 136,   0,   0, 138,   0,   0, 139,   0, 140,   0, 143, 258, 141, 142, 144, 130, 137, 132, 135,   0, 262, 131,   0, 145,   0,   0,   0,   0,   0,   0,   0, 133,   0, 134,   0, 133, 136, 134,   0, 138, 136,   0, 139, 138, 140, 131, 143, 145, 141, 142, 144, 130, 137, 132, 135, 130, 137, 132, 135,   0,   0,   0,   0,   0,   0,   0,   0, 133,   0, 134,   0,   0, 136,   0,   0, 138, 214,   0, 139,   0, 140, 131, 143, 145, 141, 142, 144, 130, 137, 132, 135, 133,   0, 134,   0,   0, 136,   0,   0, 138,   0,   0, 139,   0, 140,   0, 143,   0, 141, 142, 144, 130, 137, 132, 135,   0, 133, 131, 134, 145,   0, 136,   0,   0, 138,   0,   0, 139,   0, 140,   0, 143,   0, 141, 142,   0, 130, 137, 132, 135, 133,   0, 134, 145, 133, 136, 134,   0, 138, 136,   0, 139,   0, 140,   0,   0,   0, 141,   0,   0, 130, 137, 132, 135, 130, 137, 132, 135 };extern short  yypgo[];short  yypact []={-1000,  30,-1000,-1000,-1000,  16,  68,-1000,-1000,  41, 226,-1000,  41,-1000,-1000,-1000,-1000,-1000, 164, 220, 163,-1000,  38, 107,-1000, 211, 211,  17, 149,  -7,-1000,-100, 204,-1000,-1000,  41,-1000,  41,  41, 285, 283, 281,-1000,-1000,-1000, 177, 129, 149, 107, 123, 114,  66,-1000,-1000,-1000, 176, 128, 812,-1000,-1000,-1000,-1000,-1000,-1000,  59,-1000,  69,-1000,-1000,  72,-1000, -28,  20,-1000,  23,-1000,-1000, 127, 825,-1000,-1000,-1000, 282,-1000,-1000, 125,1270, 480, 160, 825, 825, 825, 825, 825, 874, 409,-1000, 759, 203,-1000,-1000,-1000,-1000,-1000,-1000, 159,  41,  67,-1000, 107, 154,-1000,-1000, 158, 281,-1000,-1000, 107,-1000,-1000,-1000,-1000,  12,  57,-1000,-1000,-1000,1270,-1000,-1000, 825, 825, 746, 688, 675, 626, 613, 825, 555, 542, 493, 825, 825, 825, 825, 825,  31,-1000,1270, 480,-1000,-1000, 825, 276,-1000, 160, 160, 160, 160, 160, 160, 409, 175,1210, 212,-1000,  62,1270,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  29,-1000,-1000,-1000, 293,  43, 355,1270,-1000, 825, 254, 825, 254, 825, 300, 825,-1000, 825, 437,1323, 825, 701, 825,1214, 825, 570,1319,1174,1270,1270, 148, 480,  31,1150,-1000, 169, 825,-1000, 124, 195, 212, 825,-1000,  69,-1000,-1000,   2,-1000,-1000,1097,-1000, 351, 351, 351, 351, 825, 351,  55,  53, 422, 269,-1000,  40, 351, 197, 192,-1000, 186, 182, 199, 825, 241,  10,1270,1270,1270,1270,1270,1270,1270,1270, 825,-1000,-1000, 132,-1000, 864, 160, 100,-1000, 112, 124,1270,-1000,-1000,-1000, 218,-1000,-1000, 213, 167,1246,-1000,-1000,-1000,-1000,1072,  50,-1000,-1000,-1000, 825, 825, 825, 825,-1000,1048,-1000,-1000,  27,1295,-1000,-1000,  75, 181,-1000, 179, 351,-1000,-1000,1010, 974,  35, 928,-1000,-1000,-1000, 166, 825,-1000,-1000,-1000, 825,-1000,-1000, 892,  21,  -4,-1000,-1000 };extern short  yyr1[];short  yypgo []={   0, 386,   8, 385, 380, 379, 378, 377, 376, 375, 374, 373, 372, 370,   0,   2,  11,  24, 369, 267,  90, 264, 368, 367, 364,  26,  17, 360,   3, 121,  82, 358, 357, 351,   1, 349, 348, 347, 344,  36, 342,  15,   9, 332, 327,  37, 270, 326,  20,  41, 321, 319,  72, 318, 317,  81, 315, 313, 312,  25,  35, 310, 309, 300, 299, 294, 288 };extern short  yyr2[];short  yyr1 []={   0,   1,   1,  32,  32,  33,  33,  35,  33,  33,  36,  38,  38,  41,  41,  43,  43,  44,  44,  44,  40,  40,  40,  18,  18,  17,  17,  17,  17,  17,  46,  20,  20,  20,  21,  21,  19,  19,  19,  22,  22,  10,  10,  47,  47,  49,  49,  23,  23,  11,  11,  50,  50,  52,  52,  45,  53,  45,  28,  28,  28,  28,  28,  30,  30,  30,  30,  30,  30,  29,  29,  29,  29,  29,  29,  29,   9,   9,   9,  12,  54,  54,  54,  34,  56,  34,  57,  57,  55,  55,  55,  55,  55,  59,  59,  60,  60,  48,  48,  51,  51,  58,  58,  61,  39,  39,  62,  63,  64,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  37,  13,  65,  65,  65,   7,   4,   3,   5,   6,   8,  66,   2,  15,  15,  31,  31,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  25,  26,  26,  26,  26,  26,  26,  26,  27,  27,  24 };extern short  yychk[];short  yyr2 []={   0,   2,   0,   1,   1,   2,   3,   0,   4,   2,   2,   2,   0,   2,   0,   3,   4,   3,   4,   0,   3,   2,   2,   1,   0,   2,   2,   1,   1,   3,   1,   2,   1,   1,   0,   2,   1,   1,   1,   5,   3,   2,   3,   1,   3,   1,   3,   5,   3,   2,   3,   1,   3,   2,   1,   1,   0,   4,   1,   1,   3,   2,   1,   2,   3,   3,   4,   1,   3,   2,   3,   3,   4,   3,   3,   2,   1,   2,   2,   2,   1,   3,   1,   1,   0,   4,   1,   1,   1,   1,   3,   6,   1,   1,   3,   1,   4,   0,   1,   0,   1,   0,   1,   1,   1,   1,   4,   3,   1,   2,   1,   2,   2,   2,   7,   4,   2,   2,   2,   2,   3,   3,   1,   2,   2,   2,   1,   1,   2,   3,   2,   1,   4,   3,   4,   6,   4,   0,   2,   1,   0,   1,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   4,   4,   4,   4,   4,   4,   4,   4,   5,   3,   3,   1,   2,   2,   2,   2,   2,   2,   2,   4,   4,   4,   1,   2,   3,   3,   1,   1,   1,   1,   1,   3,   2,   0,   2,   5,   2,   3,   4,   3,   2,   2,   1 };extern short  yydef[];short  yychk []={-1000,  -1, -32, -33, 256, -18, -37, -17,  59, -46, -20,  34, -19, -23, -22,  33, 128, 129, -11, -21, -10,  57, -34, -29, -55,  -9,  50, -12, -30, -57, 256,  11,   2,  57, -20, -46, -21, -19,  52,  49,  35,  52,  57,  56, -35,  50,  54, -30, -29, -30, -29, -54,  51,   2, 256,  50,  54, -58,  58, 128, 129,  50, -20, -21, -50, -52, -20,   2,   2, -47, -49,   2, -56, -36, -38,  51,  55,  -2, -66,  51,  51,  51,  56,  51,  55,  -2, -14,  52, -16,  11,  14,   8,  31,  30,  48,  50, -24, -27,   2,   4,   5, 113,   3, -13,  59, -51,  57, -45, -28, -29, -30,  22, 256, -48,  56,  58, -55, -29, -39, -40, -62, -63, -17, 256, -64,  52,  55, -14,   2,  55,  26,  56,  28,   6,   8,  29,  11,  27,  14,  17,  19,  23,  24,  21,  25,  58, -59, -60, -14, -61,  52,  30,  54,  32,  50, -16, -16, -16, -16, -16, -16,  50, -25, -14, -20,  51, -31, -14,  50,  53, -52,  56,  22,  -2,  53, -49,  -2, -45,  57,  57, -43, -41, -44, -14, -14, -14,  58, -14,  58, -14,  58, -14,  58, -14,  58, -14, -14,  58, -14,  58, -14,  58, -14, -14, -14, -14, -14, -48,  56, -59, -14,   2, -25,  51,  51, -26,  50,  11,  56,  51, -53,  -2,  57, -41, -42,  53, -14, -39,  -4,  -3,  -5,  -7,  -6,  -8,  41,  42,  36,  37,  57, 256, -65,  38,  43,  44,  45,  40,   2,  47,  46, -17, -14, -14, -14, -14, -14, -14, -14, -14,  22,  53, -60, -48,  55,  51, -16,  54,  51, -26, -26, -14, -28,  53,  57, -42, -42, -42, -42, -15, -14, -42,  57,  57,  57, -14,   2,  57,  53, -42,  50,  50,  50,  50,  22, -14,  22,  57, -34, -14,  53,  55,  -2,  51,  39,  43,  51,  57,  57, -14, -14, -15, -14,  22,  57,  55,  50,  50, -42,  51,  51,  57,  51,  51, -14, -15,  51,  57,  57 };#ifndef lintstatic char yaccpar_sccsid[] = "@(#)yaccpar	4.1	(Berkeley)	2/11/83";#endif## define YYFLAG -1000# define YYERROR goto yyerrlab# define YYACCEPT return(0)# define YYABORT return(1)/*	parser for yacc output	*/#ifdef YYDEBUGint yydebug = 0; /* 1 for debugging */#endifYYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */int yychar; /* current input token number */int yynerrs;  /* number of errors */short yyerrflag;  /* error recovery flag */int yyparse( void ) {	short yys[YYMAXDEPTH];	short yyj, yym;	register YYSTYPE *yypvt;	register short yystate, *yyps, yyn;	register YYSTYPE *yypv;	register short *yyxi;	yystate = 0;	yychar = -1;	yynerrs = 0;	yyerrflag = 0;	yyps= &yys[-1];	yypv= &yyv[-1]; yystack:    /* put a state and value onto the stack */#ifdef YYDEBUG	if( yydebug  ) printf( "state %d, char 0%o\n", yystate, yychar );#endif		if( ++yyps> &yys[YYMAXDEPTH] ) { yyerror( "Yacc stack overflow" ); return(1); }		*yyps = yystate;		++yypv;		*yypv = yyval; yynewstate:	yyn = yypact[yystate];	if( yyn<= YYFLAG ) goto yydefault; /* simple state */	if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */		yychar = -1;		yyval = yylval;		yystate = yyn;		if( yyerrflag > 0 ) --yyerrflag;		goto yystack;		} yydefault:	/* default state action */	if( (yyn=yydef[yystate]) == -2 ) {		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;		/* look through exception table */		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */		while( *(yyxi+=2) >= 0 ){			if( *yyxi == yychar ) break;			}		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */		}	if( yyn == 0 ){ /* error */		/* error ... attempt to resume parsing */		switch( yyerrflag ){		case 0:   /* brand new error */			yyerror( "Syntax error" );		yyerrlab:			++yynerrs;		case 1:		case 2: /* incompletely recovered error ... try again */			yyerrflag = 3;			/* find a state where "error" is a legal shift action */			while ( yyps >= yys ) {			   yyn = yypact[*yyps] + YYERRCODE;			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){			      yystate = yyact[yyn];  /* simulate a shift of "error" */			      goto yystack;			      }			   yyn = yypact[*yyps];			   /* the current yyps has no shift onn "error", pop stack */#ifdef YYDEBUG			   if( yydebug ) printf( "Error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );#endif			   --yyps;			   --yypv;			   }			/* there is no state on the stack with an error shift ... abort */	yyabort:			return(1);		case 3:  /* no shift yet; clobber input char */#ifdef YYDEBUG			if( yydebug ) printf( "Error recovery discards char %d\n", yychar );#endif			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */			yychar = -1;			goto yynewstate;   /* try again in the same state */			}		}	/* reduction by production yyn */#ifdef YYDEBUG		if( yydebug ) printf("Reduce %d\n",yyn);#endif		yyps -= yyr2[yyn];		yypvt = yypv;		yypv -= yyr2[yyn];		yyval = yypv[1];		yym=yyn;			/* consult goto table to find next state */		yyn = yyr1[yyn];		yyj = yypgo[yyn] + *yyps + 1;		if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];		switch(yym){			case 2:ftnend(); break;case 3:{ curclass = SNULL;  blevel = 0; } break;case 4:{ curclass = SNULL;  blevel = 0; } break;case 5:{  yypvt[-1].nodep->in.op = FREE; } break;case 6:{  yypvt[-2].nodep->in.op = FREE; } break;case 7:{				defid( tymerge(yypvt[-1].nodep,yypvt[-0].nodep), curclass==STATIC?STATIC:EXTDEF );#ifndef LINT				pfstab(stab[yypvt[-0].nodep->tn.rval].sname);#endif				} break;case 8:{  			    if( blevel ) cerror( "Function level error" );			    if( reached ) retstat |= NRETVAL; 			    yypvt[-3].nodep->in.op = FREE;			    ftnend();			    } break;case 12:{  blevel = 1; } break;case 14:{  bccode();			    locctr(PROG);			    } break;case 15:{  yypvt[-1].nodep->in.op = FREE; #ifndef LINT			    plcstab(blevel);#endif			    } break;case 16:{  yypvt[-2].nodep->in.op = FREE; #ifndef LINT			    plcstab(blevel);#endif			    } break;case 17:{  yypvt[-1].nodep->in.op = FREE; } break;case 18:{  yypvt[-2].nodep->in.op = FREE; } break;case 20:{ curclass = SNULL;  yypvt[-2].nodep->in.op = FREE; } break;case 21:{ curclass = SNULL;  yypvt[-1].nodep->in.op = FREE; } break;case 22:{  curclass = SNULL; } break;case 24:{  yyval.nodep = mkty(INT,0,INT);  curclass = SNULL; } break;case 25:{ yyval.nodep = yypvt[-0].nodep; } break;case 27:{  yyval.nodep = mkty(INT,0,INT); } break;case 28:{ curclass = SNULL; } break;case 29:{ types(yypvt[-2].nodep, yypvt[-0].nodep, NIL); } break;case 30:{  curclass = yypvt[-0].intval; } break;case 31:{ yypvt[-1].nodep->in.left = yypvt[-0].nodep;			   /* Call types to merge several types into			      one; only call if there is more than one			      type present in the declaration.			   */			   if (yypvt[-0].nodep != NIL) types(yypvt[-1].nodep);			 } break;case 34:{ yyval.nodep = NIL; } break;case 35:{ yypvt[-1].nodep->in.left = yypvt[-0].nodep; } break;case 39:{ yyval.nodep = dclstruct(yypvt[-4].intval); } break;case 40:{ yyval.nodep = rstruct(yypvt[-0].intval,0,cvcheck(yypvt[-2].nodep));  stwart = instruct;			 } break;case 41:{ yyval.intval = bstruct(-1,0,cvcheck(yypvt[-1].nodep)); stwart = SEENAME;			 } break;case 42:{ yyval.intval = bstruct(yypvt[-0].intval,0,cvcheck(yypvt[-2].nodep)); stwart = SEENAME;			 } break;case 45:{  moedef( yypvt[-0].intval ); } break;case 46:{  strucoff = yypvt[-0].intval;  moedef( yypvt[-2].intval ); } break;case 47:{ yyval.nodep = dclstruct(yypvt[-4].intval);  } break;case 48:{ yyval.nodep = rstruct(yypvt[-0].intval,yypvt[-1].intval,cvcheck(yypvt[-2].nodep)); } break;case 49:{ yyval.intval = bstruct(-1,yypvt[-0].intval,cvcheck(yypvt[-1].nodep));  stwart=0;			 } break;case 50:{ yyval.intval = bstruct(yypvt[-0].intval,yypvt[-1].intval,cvcheck(yypvt[-2].nodep));  stwart=0;			 } break;case 53:{ curclass = SNULL;  stwart=0; yypvt[-1].nodep->in.op = FREE; } break;case 54:{  if( curclass != MOU ){				curclass = SNULL;				}			    else {				sprintf( fakename, "$%dFAKE", fake++ );#ifdef FLEXNAMES				/* No need to hash this, we won't look it up */				defid( tymerge(yypvt[-0].nodep, bdty(NAME,NIL,lookup( savestr(fakename), SMOS ))), curclass );#else				defid( tymerge(yypvt[-0].nodep, bdty(NAME,NIL,lookup( fakename, SMOS ))), curclass );#endif				werror("Structure typed union member must be named");				}			    stwart = 0;			    yypvt[-0].nodep->in.op = FREE;			    } break;case 55:{ defid( tymerge(yypvt[-1].nodep,yypvt[-0].nodep), curclass);  stwart = instruct; } break;case 56:{yyval.nodep=yypvt[-2].nodep;} break;case 57:{ defid( tymerge(yypvt[-4].nodep,yypvt[-0].nodep), curclass);  stwart = instruct; } break;case 60:{  if( !(instruct&INSTRUCT) ) uerror( "Field outside of structure" );			    if( yypvt[-0].intval<0 || yypvt[-0].intval >= FIELD ){				uerror( "Illegal field size" );				yypvt[-0].intval = 1;				}			    defid( tymerge(yypvt[-3].nodep,yypvt[-2].nodep), FIELD|yypvt[-0].intval );			    yyval.nodep = NIL;			    } break;case 61:{  if( !(instruct&INSTRUCT) ) uerror( "Field outside of structure" );			    falloc( stab, yypvt[-0].intval, -1, yypvt[-2].nodep );  /* alignment or hole */			    yyval.nodep = NIL;			    } break;case 62:{  yyval.nodep = NIL; } break;case 63:{  umul:				yyval.nodep = bdty( UNARY MUL, yypvt[-0].nodep, yypvt[-1].intval ); } break;case 64:{  uftn:				yyval.nodep = bdty( UNARY CALL, yypvt[-2].nodep, 0 );  } break;case 65:{  uary:				yyval.nodep = bdty( LB, yypvt[-2].nodep, 0 );  } break;case 66:{  bary:				if( (int)yypvt[-1].intval <= 0 ) werror( "Zero or negative subscript" );				yyval.nodep = bdty( LB, yypvt[-3].nodep, yypvt[-1].intval );  } break;case 67:{  yyval.nodep = bdty( NAME, NIL, yypvt[-0].intval );  } break;case 68:{ yyval.nodep=yypvt[-1].nodep; } break;case 69:{  goto umul; } break;case 70:{  goto uftn; } break;case 71:{  goto uary; } break;case 72:{  goto bary; } break;case 73:{ yyval.nodep = yypvt[-1].nodep; } break;case 74:{				if( blevel!=0 ) uerror("Function declaration in bad context");				yyval.nodep = bdty( UNARY CALL, bdty(NAME,NIL,yypvt[-2].intval), 0 );				stwart = 0;				} break;case 75:{				yyval.nodep = bdty( UNARY CALL, bdty(NAME,NIL,yypvt[-1].intval), 0 );				stwart = 0;				} break;case 76:{ yyval.intval = 0; } break;case 77:{ yypvt[-0].nodep->in.op = FREE;			   yyval.intval = BCONST_PTR;	/* vjh005 */			 } break;case 78:{ yypvt[-0].nodep->in.op = FREE;			   yyval.intval = BVOLATILE_PTR;	/* vjh005 */			 } break;case 79:{				/* turn off typedefs for argument names */				stwart = SEENAME;				if( stab[yypvt[-1].intval].sclass == SNULL )				    stab[yypvt[-1].intval].stype = FTN;				} break;case 80:{ ftnarg( yypvt[-0].intval );  stwart = SEENAME; } break;case 81:{ ftnarg( yypvt[-0].intval );  stwart = SEENAME; } break;case 84:{yyval.nodep=yypvt[-2].nodep;} break;case 86:{  defid( yypvt[-0].nodep = tymerge(yypvt[-1].nodep,yypvt[-0].nodep), curclass);			    beginit(yypvt[-0].nodep->tn.rval);			    } break;case 88:{  nidcl( tymerge(yypvt[-1].nodep,yypvt[-0].nodep) ); } break;case 89:{  defid( tymerge(yypvt[-1].nodep,yypvt[-0].nodep), uclass(curclass) );			} break;case 90:{  doinit( yypvt[-0].nodep );			    endinit(); } break;case 91:{  endinit(); } break;case 95:{  doinit( yypvt[-0].nodep ); } break;case 96:{  irbrace(); } break;case 101:{  werror( "Old-fashioned initialization: use =" ); } break;case 103:{  ilbrace(); } break;case 106:{  #ifndef LINT			    prcstab(blevel);#endif			    --blevel;			    if( blevel == 1 ) blevel = 0;			    clearst( blevel );			    checkst( blevel );			    autooff = *--psavbc;			    regvar = *--psavbc;			    } break;case 107:{  --blevel;			    if( blevel == 1 ) blevel = 0;			    clearst( blevel );			    checkst( blevel );			    autooff = *--psavbc;			    regvar = *--psavbc;			    } break;case 108:{  if( blevel == 1 ) dclargs();			    ++blevel;			    if( psavbc > &asavbc[BCSZ-2] ) cerror( "Nesting too deep" );			    *psavbc++ = regvar;			    *psavbc++ = autooff;			    } break;case 109:{ ecomp( yypvt[-1].nodep ); } break;case 111:{ deflab(yypvt[-1].intval);			   reached = 1;			   } break;case 112:{  if( yypvt[-1].intval != NOLAB ){				deflab( yypvt[-1].intval );				reached = 1;				}			    } break;case 113:{  branch(  contlab );			    deflab( brklab );			    if( (flostat&FBRK) || !(flostat&FLOOP)) reached = 1;			    else reached = 0;			    resetbc(0);			    } break;case 114:{  deflab( contlab );			    if( flostat & FCONT ) reached = 1;			    ecomp( buildtree( CBRANCH, buildtree( NOT, yypvt[-2].nodep, NIL ), bcon( yypvt[-6].intval ) ) );			    deflab( brklab );			    reached = 1;			    resetbc(0);			    } break;case 115:{  deflab( contlab );			    if( flostat&FCONT ) reached = 1;			    if( yypvt[-2].nodep ) ecomp( yypvt[-2].nodep );			    branch( yypvt[-3].intval );			    deflab( brklab );			    if( (flostat&FBRK) || !(flostat&FLOOP) ) reached = 1;			    else reached = 0;			    resetbc(0);			    } break;case 116:{  if( reached ) branch( brklab );			    deflab( yypvt[-1].intval );			   swend();			    deflab(brklab);			    if( (flostat&FBRK) || !(flostat&FDEF) ) reached = 1;			    resetbc(FCONT);			    } break;case 117:{  if( brklab == NOLAB ) uerror( "Illegal break");			    else if(reached) branch( brklab );			    flostat |= FBRK;			    if( brkflag ) goto rch;			    reached = 0;			    } break;case 118:{  if( contlab == NOLAB ) uerror( "Illegal continue");			    else branch( contlab );			    flostat |= FCONT;			    goto rch;			    } break;case 119:{  retstat |= NRETVAL;			    branch( retlab );			rch:			    if( !reached ) werror( "Statement not reached");			    reached = 0;			    } break;case 120:{  register NODE *temp;			    idname = curftn;			    temp = buildtree( NAME, NIL, NIL );			    if(temp->in.type == TVOID)				uerror("void function %s cannot return value",					stab[idname].sname);			    temp->in.type = DECREF( temp->in.type );			    temp = buildtree( RETURN, temp, yypvt[-1].nodep );			    /* now, we have the type of the RHS correct */			    temp->in.left->in.op = FREE;			    temp->in.op = FREE;			    ecomp( buildtree( FORCE, temp->in.right, NIL ) );			    retstat |= RETVAL;			    branch( retlab );			    reached = 0;			    } break;case 121:{  register NODE *q;			    q = block( FREE, NIL, NIL, INT|ARY, 0, INT );			    q->tn.rval = idname = yypvt[-1].intval;			    defid( q, ULABEL );			    stab[idname].suse = -lineno;			    branch( stab[idname].offset );			    goto rch;			    } break;case 126:{			   procasm();		/* Read in the asm info */			   outasm(asmptr);	/* Put it out now */			 } break;case 127:{ yyval.intval = yypvt[-0].intval;			   procasm(); 		/* Read in the asm info */						/* (put out in match.c) */			 } break;case 128:{  register NODE *q;			    q = block( FREE, NIL, NIL, INT|ARY, 0, LABEL );			    q->tn.rval = yypvt[-1].intval;			    defid( q, LABEL );			    reached = 1;			    } break;case 129:{  addcase(yypvt[-1].nodep);			    reached = 1;			    } break;case 130:{  reached = 1;			    adddef();			    flostat |= FDEF;			    } break;case 131:{  savebc();			    if( !reached ) werror( "Loop not entered at top");			    brklab = getlab();			    contlab = getlab();			    deflab( yyval.intval = getlab() );			    reached = 1;			    } break;case 132:{  ecomp( buildtree( CBRANCH, yypvt[-1].nodep, bcon( yyval.intval=getlab()) ) ) ;			    reached = 1;			    } break;case 133:{  if( reached ) branch( yyval.intval = getlab() );			    else yyval.intval = NOLAB;			    deflab( yypvt[-2].intval );			    reached = 1;			    } break;case 134:{  savebc();			    if( !reached ) werror( "Loop not entered at top");			    if( yypvt[-1].nodep->in.op == ICON && yypvt[-1].nodep->tn.lval != 0 ) flostat = FLOOP;			    deflab( contlab = getlab() );			    reached = 1;			    brklab = getlab();			    if( flostat == FLOOP ) tfree( yypvt[-1].nodep );			    else ecomp( buildtree( CBRANCH, yypvt[-1].nodep, bcon( brklab) ) );			    } break;case 135:{  if( yypvt[-3].nodep ) ecomp( yypvt[-3].nodep );			    else if( !reached ) werror( "Loop not entered at top");			    savebc();			    contlab = getlab();			    brklab = getlab();			    deflab( yyval.intval = getlab() );			    reached = 1;			    if( yypvt[-1].nodep ) ecomp( buildtree( CBRANCH, yypvt[-1].nodep, bcon( brklab) ) );			    else flostat |= FLOOP;			    } break;case 136:{  savebc();			    brklab = getlab();			    ecomp( buildtree( FORCE, yypvt[-1].nodep, NIL ) );			    branch( yyval.intval = getlab() );			    swstart();			    reached = 0;			    } break;case 137:{ yyval.intval=instruct; stwart=instruct=0; } break;case 138:{  yyval.intval = icons( yypvt[-0].nodep );  instruct=yypvt[-1].intval; } break;case 140:{ yyval.nodep=0; } break;case 142:{  goto bop; } break;case 143:{			preconf:			    if( yychar==RELOP||yychar==EQUOP||yychar==AND||yychar==OR||yychar==ER ){			    precplaint:				if( hflag ) werror( "Precedence confusion possible: parenthesize!" );				}			bop:			    yyval.nodep = buildtree( yypvt[-1].intval, yypvt[-2].nodep, yypvt[-0].nodep );			    } break;case 144:{  yypvt[-1].intval = COMOP;			    goto bop;			    } break;case 145:{  goto bop; } break;case 146:{  if(yychar==SHIFTOP) goto precplaint; else goto bop; } break;case 147:{  if(yychar==SHIFTOP ) goto precplaint; else goto bop; } break;case 148:{  if(yychar==PLUS||yychar==MINUS) goto precplaint; else goto bop; } break;case 149:{  goto bop; } break;case 150:{  goto preconf; } break;case 151:{  if( yychar==RELOP||yychar==EQUOP ) goto preconf;  else goto bop; } break;case 152:{  if(yychar==RELOP||yychar==EQUOP) goto preconf; else goto bop; } break;case 153:{  if(yychar==RELOP||yychar==EQUOP) goto preconf; else goto bop; } break;case 154:{  goto bop; } break;case 155:{  goto bop; } break;case 156:{  abop:				yyval.nodep = buildtree( ASG yypvt[-2].intval, yypvt[-3].nodep, yypvt[-0].nodep );				} break;case 157:{  goto abop; } break;case 158:{  goto abop; } break;case 159:{  goto abop; } break;case 160:{  goto abop; } break;case 161:{  goto abop; } break;case 162:{  goto abop; } break;case 163:{  goto abop; } break;case 164:{  yyval.nodep=buildtree(QUEST, yypvt[-4].nodep, buildtree( COLON, yypvt[-2].nodep, yypvt[-0].nodep ) );			    } break;case 165:{  werror( "Old-fashioned assignment operator" );  goto bop; } break;case 166:{  goto bop; } break;case 168:{  yyval.nodep = buildtree( yypvt[-0].intval, yypvt[-1].nodep, bcon(1) ); } break;case 169:{ ubop:			    yyval.nodep = buildtree( UNARY yypvt[-1].intval, yypvt[-0].nodep, NIL );			    } break;case 170:{  if( ISFTN(yypvt[-0].nodep->in.type) || ISARY(yypvt[-0].nodep->in.type) ){				werror( "& before array or function: ignored" );				yyval.nodep = yypvt[-0].nodep;				}			    else goto ubop;			    } break;case 171:{  goto ubop; } break;case 172:{			    yyval.nodep = buildtree( yypvt[-1].intval, yypvt[-0].nodep, NIL );			    } break;case 173:{  yyval.nodep = buildtree( yypvt[-1].intval==INCR ? ASG PLUS : ASG MINUS,						yypvt[-0].nodep,						bcon(1)  );			    } break;case 174:{  yyval.nodep = doszof( yypvt[-0].nodep ); } break;case 175:{  yyval.nodep = buildtree( CAST, yypvt[-2].nodep, yypvt[-0].nodep );			    yyval.nodep->in.left->in.op = FREE;			    yyval.nodep->in.op = FREE;			    yyval.nodep = yyval.nodep->in.right;			    } break;case 176:{  yyval.nodep = doszof( yypvt[-1].nodep ); } break;case 177:{  yyval.nodep = buildtree( UNARY MUL, buildtree( PLUS, yypvt[-3].nodep, yypvt[-1].nodep ), NIL ); } break;case 178:{  yyval.nodep=buildtree(UNARY CALL,yypvt[-0].nodep,NIL); } break;case 179:{  yyval.nodep=buildtree(UNARY CALL,yypvt[-1].nodep,NIL); } break;case 180:{  yyval.nodep=buildtree(CALL,yypvt[-2].nodep,yypvt[-1].nodep); } break;case 181:{  if( yypvt[-1].intval == DOT ){				if( notlval( yypvt[-2].nodep ) )uerror("Structure reference must be addressable");				yypvt[-2].nodep = buildtree( UNARY AND, yypvt[-2].nodep, NIL );				}			    idname = yypvt[-0].intval;			    yyval.nodep = buildtree( STREF, yypvt[-2].nodep, buildtree( NAME, NIL, NIL ) );			    } break;case 182:{  idname = yypvt[-0].intval;			    /* recognize identifiers in initializations */			    if( blevel==0 && stab[idname].stype == UNDEF ) {				register NODE *q;#ifndef FLEXNAMES				werror( "Undeclared initializer name %.8s", stab[idname].sname );#else				werror( "Undeclared initializer name %s", stab[idname].sname );#endif				q = block( FREE, NIL, NIL, INT, 0, INT );				q->tn.rval = idname;				defid( q, EXTERN );				}			    yyval.nodep=buildtree(NAME,NIL,NIL);			    stab[yypvt[-0].intval].suse = -lineno;			} break;case 183:{  yyval.nodep=bcon(0);			    yyval.nodep->tn.lval = lastcon;			    yyval.nodep->tn.rval = NONAME;			    if( yypvt[-0].intval ) yyval.nodep->fn.csiz = yyval.nodep->in.type = ctype(LONG);			    } break;case 184:{  yyval.nodep=buildtree(FCON,NIL,NIL);			    yyval.nodep->fpn.fval = fcon;			    } break;case 185:{  yyval.nodep= buildtree(DCON,NIL,NIL);			    yyval.nodep->dpn.dval = dcon;			    } break;case 186:{  yyval.nodep = getstr(); /* get string contents */ } break;case 187:{ yyval.nodep=yypvt[-1].nodep; } break;case 188:{			yyval.nodep = tymerge( yypvt[-1].nodep, yypvt[-0].nodep );			yyval.nodep->in.op = NAME;			yypvt[-1].nodep->in.op = FREE;			} break;case 189:{ yyval.nodep = bdty( NAME, NIL, -1 ); } break;case 190:{ yyval.nodep = bdty( UNARY CALL, bdty(NAME,NIL,-1),0); } break;case 191:{  yyval.nodep = bdty( UNARY CALL, yypvt[-3].nodep, 0 ); } break;case 192:{  goto umul; } break;case 193:{  goto uary; } break;case 194:{  goto bary;  } break;case 195:{ yyval.nodep = yypvt[-1].nodep; } break;case 196:{  			    if( stab[yypvt[-1].intval].stype == UNDEF ){				register NODE *q;				q = block( FREE, NIL, NIL, FTN|INT, 0, INT );				q->tn.rval = yypvt[-1].intval;				defid( q, EXTERN );				}			    idname = yypvt[-1].intval;			    yyval.nodep=buildtree(NAME,NIL,NIL);			    stab[idname].suse = -lineno;			} break;case 198:{  			    if( stab[yypvt[-0].intval].stype == UNDEF ){				register NODE *q;				q = block( FREE, NIL, NIL, FTN|UNDEF, 0, INT );				q->tn.rval = yypvt[-0].intval;				defid( q, EXTERN );				}			    idname = yypvt[-0].intval;			    yyval.nodep=buildtree(NAME,NIL,NIL);#ifdef ONEPASS			    yyval.nodep->in.asminfo = asmptr;#endif			    stab[idname].suse = -lineno;			} break; 		}		goto yystack;  /* stack new state and value */	}