#include <stdio.h>#include <ctype.h>#include <string.h>#include "ccom_main.h"#include "cpp_main.h"#include "MacScreen.h"#include "Compiler.h"#include "Globals.h"#include "AnimateCursor.h"#define kTextFileBufferSize		16384#define kNumberOfWatchCursors	8#define kFirstWatchCursorID		128/*	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -	myFilterProc		This function is used to filter which files to show when opening a file	for compilation.  In the case of a C compiler, the only files that are	deemed worth opening are files of type 'TEXT' whose filename ends with	the suffix ".c" or ".C"	 	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/static pascal Boolean myFilterProc( FileParam *pbp ){	int	nameLength;		// Only show (ie return true for) files with names ending in ".c"		nameLength = pbp->ioNamePtr[0];		if ((pbp->ioNamePtr[nameLength-1] == '.') && (tolower(pbp->ioNamePtr[nameLength]) == 'c'))		return FALSE;	else		return TRUE;}pascal long	HandleErrorsWindow (msWindow *theWindow, short itemHit, short unused1, Ptr unused2, long unused3){	switch( itemHit )	{		case actionDoOpenWindow:			gErrorWindow = theWindow;			break;				case actionDoCloseWindow:			gErrorWindow = nil;			break;				case actionDoFixMenus:			break;				default: break;	}		return( 0 );}void HideAndClearErrors( void ){	msWindow	*errorWindow;	// Read the window info in and show the window.	if (gErrorWindow != nil)		msRemoveWindow( gErrorWindow );}void ShowErrors( const char *theErrorFileName ){	msWindow	*errorWindow;	Ptr			theText;	Str255		theFileName;	short		fRefNum;	OSErr		theErr;	long		theTextFileBufferSize;	char		*initialText = "";	long		initialTextLength = strlen(initialText);				strcpy((char *)theFileName, theErrorFileName);	c2pstr( (char *) theFileName );		// Read the window info in and show the window.	errorWindow = msGetWindow( kErrorWindowID, (ProcPtr)HandleErrorsWindow, nil );	LockWindowItems( errorWindow ); 		// Clear the error window of any previous errors.	msSetWindowItemText( errorWindow, ErrorTextItem, (Ptr)initialText, initialTextLength );			// Initialise 'theText'.	// Read the text here into 'theText' and setting 'textLength'.		theText = NewPtr( kTextFileBufferSize );	if (theText != nil)		{		// Read in the data from the error file.				if (FSOpen( theFileName, 0, &fRefNum ) == noErr)			{			theTextFileBufferSize = kTextFileBufferSize;			theErr = FSRead( fRefNum, &theTextFileBufferSize, theText );			FSClose(fRefNum);						if (theErr == eofErr || theErr == noErr)				// Copy the text into the msWindow.				msSetWindowItemText( errorWindow, ErrorTextItem, (Ptr)theText, theTextFileBufferSize );			}				DisposePtr( theText );				}}static void SetFileTypeAndCreator( char *theName, OSType fType, OSType fCreator ){	// Set the file attributes for the named file in the current default	// directory.		OSErr	theErr;	FInfo	fndrInfo;	Str255	thePascalName;			strcpy( (char *) thePascalName, theName );	(void) c2pstr( (char *) thePascalName );		theErr = GetFInfo( thePascalName, 0, &fndrInfo );	if (theErr == noErr)		{		fndrInfo.fdType = fType;		fndrInfo.fdCreator = fCreator;				theErr = SetFInfo( thePascalName, 0, &fndrInfo );		if (theErr != noErr)			Debugger();		}}/*	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -	CompileFile		Prompt a user to select a text file named with the suffix ".c".	This file is passed to the preprocessor and the resulting intermediate	file is passed to the C compiler.  The output is saved in a user-specified	file.		Upon completion, the temporary file is removed.	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/OSErr CompileFile( void ){	SFReply			theReply1, theReply2;	Point			where;	SFTypeList		typeList;	int				nameLength;	Str255			outputFileName;	char			intermediateFileName[L_tmpnam];	char			errFileName[L_tmpnam];	FILE			Old_stdin;	long			errFileSize;		FileFilterUPP	myFileFilterUPP;				int argc, cppErr, compErr;	char *argv[2] = {"MacVaxcc"};	cppErr = compErr = 0;	HideAndClearErrors();	typeList[0] = 'TEXT';	where.h = 50;	where.v = 50;		myFileFilterUPP = NewFileFilterProc(&myFilterProc);	SFGetFile( where, nil, nil, 1, typeList, nil, &theReply1 );	DisposeRoutineDescriptor(myFileFilterUPP);	if (theReply1.good)		{			nameLength = theReply1.fName[0];				memcpy( outputFileName, theReply1.fName,  nameLength+1 );				if ( outputFileName[nameLength-1] != '.' || nameLength > 30)			{			nameLength += 2;			outputFileName[0] = nameLength;			}		outputFileName[nameLength-1] = '.';		outputFileName[nameLength]   = 's';				tmpnam( intermediateFileName );		SFPutFile( where, "\pName the output file:", outputFileName, nil, &theReply2 );		if ( theReply2.good )			{			Old_stdin = *stdin;						tmpnam( errFileName );			SetVol( nil, theReply2.vRefNum );						freopen( intermediateFileName, "w", stdout );			freopen( errFileName, "w", stderr );			SetVol( nil, theReply1.vRefNum );						/* Since we're in for a wait, start the watch cursor... */			StartSpinning( kNumberOfWatchCursors, kFirstWatchCursorID );						/* Call the preprocessor */			argc = 2;			argv[1] = p2cstr(theReply1.fName);			cppErr = cpp(argc, argv);			SetVol( nil, theReply2.vRefNum );						fclose(stdin);			fclose(stdout);			fflush(stderr);			errFileSize = ftell( stderr );			if (cppErr)				{								// The preprocessor has encountered an error.								SysBeep(5);								fclose(stderr);				ShowErrors( errFileName );				}			else				{								// Redirect the appropriate streams:								freopen( p2cstr(theReply2.fName), "w", stdout );											// Call the compiler				argc = 2;				argv[1] = (char *) intermediateFileName;				compErr = compile(argc, argv);					fflush(stderr);								errFileSize = ftell( stderr );								fclose(stdin);				fclose(stdout);				fclose(stderr);					if (compErr)					{										// The compiler has encountered an error.										SysBeep(5);					ShowErrors( errFileName );										remove( (char *) theReply2.fName );					}				}			if ( !cppErr && !compErr && errFileSize>0)				{								// The preprocessor or the compiler has issued some warnings.								ShowErrors( errFileName );				}			if (!cppErr && !compErr)				SetFileTypeAndCreator( (char *)theReply2.fName, 'TEXT', 'VXAS' );			remove( errFileName );			remove( intermediateFileName );			*stdin = Old_stdin;		// So that CodeWarrior doesn't open its SIOUX window									// on the 2nd compile.									/* Stop the animated watch cursor */			StopSpinning();						}		else			{			/* The user cancelled the "Name Output..." operation. */						return noErr;			}		}	else		{		/* The user cancelled the "Compile" operation. */				return noErr;		}				return noErr;}/*	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -	PreprocessFile		Prompt a user to select a text file named with the suffix ".c".	This file is passed to the preprocessor and the output is saved in a user-specified	file.		Upon completion, the temporary file is removed.	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/OSErr PreprocessFile( void ){	SFReply			theReply1, theReply2;	Point			where;	SFTypeList		typeList;	int				nameLength;	Str255			outputFileName;	char			errFileName[L_tmpnam];	FILE			Old_stdin;	long			errFileSize;		//FileFilterUPP	myFileFilterUPP;				int argc, cppErr, compErr;	char *argv[2] = {"MacVaxcc"};	HideAndClearErrors();	typeList[0] = 'TEXT';	where.h = 50;	where.v = 50;		//myFileFilterUPP = NewFileFilterProc(&myFilterProc);	SFGetFile( where, nil, nil, 1, typeList, nil, &theReply1 );	//DisposeRoutineDescriptor(myFileFilterUPP);		if (theReply1.good)		{			nameLength = theReply1.fName[0];				memcpy( outputFileName, theReply1.fName,  nameLength+1 );				if ( outputFileName[nameLength-1] != '.' || nameLength > 30)			{			nameLength += 2;			outputFileName[0] = nameLength;			}		outputFileName[nameLength-1] = '.';		outputFileName[nameLength]   = 'i';		SFPutFile( where, "\pName the output file:", outputFileName, nil, &theReply2 );		if ( theReply2.good )			{			Old_stdin = *stdin;						tmpnam( errFileName );						SetVol( nil, theReply2.vRefNum );			freopen( p2cstr( theReply2.fName ), "w", stdout );			freopen( errFileName, "w", stderr );									SetVol( nil, theReply1.vRefNum );						/* Since we're in for a wait, start the watch cursor... */			StartSpinning( kNumberOfWatchCursors, kFirstWatchCursorID );			/* Call the preprocessor */			argc = 2;			argv[1] = p2cstr(theReply1.fName);			cppErr = cpp(argc, argv);						errFileSize = ftell( stderr );			fclose(stdin);			fclose(stdout);								fclose(stderr);			if (cppErr)				{								// The preprocessor has encountered an error.													ShowErrors( errFileName );								remove( (char *) theReply2.fName );				}			else if (errFileSize>0)				{								// The preprocessor has issued some warnings.								ShowErrors( errFileName );				}							SetVol( nil, theReply2.vRefNum );			if (!cppErr)				SetFileTypeAndCreator( (char *)theReply2.fName, 'TEXT', 'R*ch' );							remove( errFileName );			*stdin = Old_stdin;		// So that CodeWarrior doesn't open its SIOUX window									// on the 2nd compile.						/* Stop the animated watch cursor */			StopSpinning();			}		else			{			/* The user cancelled the "name output" operation. */						return noErr;			}		}	else		{		/* The user cancelled the "Preprocess..." operation. */				return noErr;		}				return noErr;}